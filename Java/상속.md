# Java - 상속

## 1. 상속

기존 상위 클래스의 자산(멤버)을 자식(하위) 클래스에서 재사용하기 위한 것

- 상위 클래스의 생성자와 초기화 블록은 상속하지 않음
- 코드 절감 → 유지 보수성 향상
- extends 키워드 사용

### **Object 클래스**

모든 클래스의 조상 클래스

- 별도의 extends 선언이 없는 클래스들은 extends Object가 생략됨
- 따라서 모든 클래스에는 Object 클래스에 정의된 메서드가 있음

상속의 관계는 is a (kind of) 관계라고 함

- Person is a Object / SpiderMan is a Person
    
    ![상속 관계, 상속 관계, 아빠가 같다](image.png)
    
    상속 관계, 상속 관계, 아빠가 같다
    

### **단일 상속**

자바는 단일 상속만 지원하는 대신 interface와 포함 관계(has a)로 단점 극복

- 포함 관계
    
    상속 이외 클래스를 재활용하는 방법
    
    2개 이상의 클래스에서 특성을 가져올 때 하나는 상속, 나머지는 멤버 변수로 처리
    
    ![image.png](image%201.png)
    

### Sealed class

봉인된 클래스로 내가 관리하는 특정 클래스에게만 상속 가능

의도치 않은 상속으로 인한 복잡성과 혼란 방지

명확한 역할과 직무 분류가 중요한 개념에서 주로 사용

- 작성법
    
    sealed 키워드를 사용하고 상속을 허락하는 클래스를 permits 뒤에 나열
    
    구현 클래스는 다음 키워드 중 하나 사용 필요
    
    - sealed: 추가적으로 permits 하위 클래스 나열 필요
    - final: 더 이상 상속받을 수 없는 클래스
    - non-sealed: 자유롭게 상속 가능

```java
package com.ssafy.day03.a_inheritance.person;

public class Person {
	String name;
	
	void eat() {
		System.out.println("냠냠");
	}
	
	void jump() {
		System.out.println("폴짝");
	}
}

```

```java
package com.ssafy.day03.a_inheritance.person;

public class Spider {
	void jump() {
		System.out.println("자기 키 * 100배 jump");
	}
	
	void fireWeb() {
		System.out.println("슉슉~");
	}
}

```

```java
package com.ssafy.day03.a_inheritance.person;

public class SpiderMan extends Person {
	Spider spider; // has a
	boolean isSpider;
	
	SpiderMan() {};
	
	SpiderMan(Spider spider, boolean isSpider) {
		this.spider = spider;
		this.isSpider = isSpider;
	}
	
	void fireWeb() {
		if (this.isSpider) {
			spider.fireWeb();
		} else {
			System.out.println("사람일 때는 안 되지.");
		}
	}
	
	void jump() {
		if (this.isSpider) {
			spider.jump();
		} else {
			//System.out.println("폴짝");
			super.jump();
		}
	}
	
	void jump(int 도움닫기) {
		System.out.println("일단 " + 도움닫기 + "까지 이동");
		this.jump();
	}
}
```

```java
package com.ssafy.day03.a_inheritance.person;

public class SpiderManTest {

    public static void main(String[] args) {
        // TODO:  SpiderMan 객체를 만들고 기능을 사용해보자.
    	SpiderMan sman = new SpiderMan(new Spider(), true);
    	sman.eat();
    	sman.jump(); // Person.jump --> SpiderMan.jump
    	sman.jump(100);
    	sman.fireWeb();
        // END
    }
}
```

## 2. 메서드 재정의

- **메서드 오버라이딩(overriding)**
    
    조상 클래스에 정의된 메서드를 자식 클래스에서 적합하게 수정하는 
    

- **super 키워드**
    
    this 통해 멤버에 접근했듯 super 통해 조상 클래스 멤버 접근
    
    super.을 이용해 조상의 코드 재사용
    
    생성자의 첫 줄에만 this() 또는 super()가 올 수 있음
    
    → 명시적으로 호출하지 않는 경우 컴파일러가 super() 삽입
    
    ⇒ 결론적으로 맨 상위의 Object까지 객체가 다 만들어지는 구조
    

![1. MCP 2. CCP 3. PPP](image%202.png)

1. MCP 2. CCP 3. PPP

![image.png](image%203.png)

- **Annotation**
    
    사전적 의미: 주석
    
    컴파일러, JVM, 프레임워크 등이 보는 주석
    
    소스코드에 메타 데이터를 삽입하는 형태
    
    - **기본 예**
        - @Deprecated
        - @Override
            
            반드시 super class에 선언되어 있는 메서드여야 함
            
            컴파일러에게 해당 메서드는 override한 메서드임을 알려 줌 → 안정적으로 재정의 가능
            
        - @SuppressWarnings
            
            컴파일러에게 사소한 warning의 경우 신경 쓰지 말라고 알려 줌
            
    

## 3. package & import

- Package
    - PC의 많은 파일 관리 → 폴더 이용
    - 프로그램의 많은 클래스 → 패키지 이용
        
        .를 통해 계층적 접근
        
        물리적으로 패키지는 클래스 파일을 담고 있는 디렉터리
        
        package name + class name으로 클래스 구분 → fully qualified name
        
    - 선언
        
        ```java
        package pacakge_name;
        ```
        
        첫 줄에 하나의 패키지만 선언
        
        모든 클래스는 반드시 하나의 패키지에 속
        
        - 생략 시 default pacakge에 속하는데 가급적 사용 X
        
    - 일반적인 package naming 룰
        
        ![image.png](image%204.png)
        

- **import**
    
    다른 패키지에 선언된 클래스를 사용하기 위한 키워드
    
    패키지와 클래스 선언 사이에 위치
    
    패키지와 달리 여러 번 선언 가능
    
    - 선언
        
        ```java
        import 패키지명.클래스명;
        import 패키지명.*; // 하위 패키지까지 import 하지는 않음
        
        // import한 패키지의 클래스 이름이 동일해 명확히 구분해야 할 때
        // 클래스 이름 앞에 전체 패키지 명을 입력
        java.util.List list = new java.util.ArrayList();
        
        //default import package
        import java.lang.*;
        ```
        

![image.png](image%205.png)

## 4. 제한자

클래스, 변수, 메서드 선언부에 함께 사용되어 부가적 의미 부여

- **종류**
    - **접근 제한자**: public, protected, (default = package), private
    - **그 외 제한자**
        - static: 클래스
        - final: 수정 불가
        - abstract: 추상
        - synchronized: 멀티스레드에서의 동기화 처리
        
    - 하나의 대상에 여러 제한자를 조합 가능하나 접근 제한자는 하나만 사용 가능

- **final**
    - final class - 더 이상 확장 불가
        
        상속 금지 → 오버라이드 방지
        
    - final method - 더 이상 재정의 불가
        
        overriding 금지
        
    - final variable - 더 이상 값 변경 불가
        - Blank final
            
            값이 할당되지 않은 멤버 변수
            
            - final 멤버 변수에 초기 값이 할당되면 모든 객체는 같은 값을 사용해야 함
            - 객체가 생성되면 값을 변경할 기회가 없기 때문에 반드시 생성자에서 1회 초기화 가능
        - static final
            
            
- **접근 제한자**
    
    ![image.png](image%206.png)
    
    - method override 조건
        
        부모의 제한자 범위와 같거나 넓은 범위로만 사용 가능
        
        ex) protected(부모) → public(자식)
        

```java
package com.ssafy.day03.b_import;

import java.io.File;
import java.text.DateFormat;
import java.util.Date;
import java.util.List;

import static java.lang.Math.PI;
// TODO: import 되는 패키지들을 살펴보자.

// END

public class ImportTest {
    // TODO: 다음의 요청 사항들을 처리하시오.
    //  1. Object 타입의 객체를 선언해보자. import 되는 내용은?
	Object obj;
    //  2. code assist를 통해 DateFormat 타입의 객체를 선언해보자.
	DateFormat format;
    //  3. 아래 주석을 해지하고 오류를 수정해보자.
    File file;
    Date date;
    //  4. java.awt 패키지의 List 타입 변수를 선언해보자. -> 안 나와서 생략
    //  5. java.util 패키지의 List 타입 변수를 선언해보자.
    List list;
    // END
    public static void main(String[] args) {
        // TODO: static import를 통해 다음을 처리하시오.
        //  1. Math 클래스의 PI를 출력해보자.
    	double d = Math.PI;
    	double d2 = PI;
    	
        //  2. static import를 통해 10과 20 중 최대값을 출력해보자.
        //  3. code assist를 통해 10과 20 중 최소값을 출력해보자.

        // END
    }

}

```

```java
package com.ssafy.day03.c_modifier.last;

public class BlankFinalTest {
	// Blank final
    private final String bloodType;

    // TODO: 위 코드가 정상적으로 컴파일되도록 처리하고 객체를 만들어보자.
    public BlankFinalTest(String bloodType) {
    	this.bloodType = bloodType;
    }
    // END
}
```

```java
package com.ssafy.day03.c_modifier.access.p1;

public class Parent {
    public int publicVar;
    protected int protectVar;
    int defaultVar;
    @SuppressWarnings("unused")
    private int privVar;

    public void useMember() {
        this.publicVar = 10;
        this.protectVar = 10;
        this.defaultVar = 10;
        this.privVar = 10;
    }
}
```

```java
package com.ssafy.day03.c_modifier.access.p1;

// TODO: Parent를 상속받고 Parent의 member들에 접근해보세요.
 public class SamePackageChildClass extends Parent {
	 
	 public void useMember() {
	        this.publicVar = 10;
	        this.protectVar = 10;
	        this.defaultVar = 10;
	        this.privVar = 10; // 멤버로 가지고 있지만 못 씀
	    }
    // END
}

```

```java
package com.ssafy.day03.c_modifier.access.p1;

public class SamePackageSomeClass {
    public void method() {
        // TODO: Parent 객체를 생성하고 이를 통해서 Parent의 멤버에 접근해보세요.
    	Parent p = new Parent();
    	p.publicVar = 1;
    	p.protectVar = 1;
    	p.defaultVar = 1;
    	//p.privVar = 1;
        // END
    }
}

```

```java
package com.ssafy.day03.c_modifier.access.p2;

import com.ssafy.day03.c_modifier.access.p1.Parent;

// TODO: Parent를 상속받고 Parent의 member들에 접근해보세요.
 public class OtherPackageChildClass extends Parent {
	 
	 public void useMember() {
	        this.publicVar = 10;
	        this.protectVar = 10;
	        //this.defaultVar = 10;
	        //this.privVar = 10; // 멤버로 가지고 있지만 못 씀
	    }
    // END
}

```

```java
package com.ssafy.day03.c_modifier.access.p2;

import com.ssafy.day03.c_modifier.access.p1.Parent;

public class OtherPackageSomeClass {
    public void method() {
        // TODO: Parent 객체를 생성하고 이를 통해서 Parent의 멤버에 접근해보세요.
    	Parent p = new Parent();
    	p.publicVar = 1;
    	//p.protectVar = 1;
    	//p.defaultVar = 1;
    	//p.privVar = 1;
        // END
    }
}

```

```java
package com.ssafy.day03.d_sealed;

// TODO: SealedStudyGroup을 sealed로 선언하고 Algo, Java, CS에게 상속을 허락해보세요.
 sealed class SealedStudyGroup permits Algo, Java, CS {
    public void study() {
        System.out.println("공부 공부 공부!!");
    }
}

// END

// TODO: Algo, Java, CS 클래스를 각각 final, sealed, non-sealed 형태로 작성해보세요.
final class Algo extends SealedStudyGroup {}
sealed class Java extends SealedStudyGroup permits Spring{}
non-sealed class CS extends SealedStudyGroup{}
// END

// TODO: Java와 CS를 각각 상속받는 Spring과 Network를 구성해보세요.
final class Spring extends Java{}
class Network extends CS{}
// END
public class SealedTest {

    public static void main(String[] args) {
        SealedStudyGroup group = new SealedStudyGroup();
        group.study();

    }
}
```