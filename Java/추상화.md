# Java - 추상화

### 1. 객체지향 프로그래밍

- **OOP is A P.I.E**
    
    Abstraction(추상화): 현실의 객체를 추상화. 한 사람을 아빠로 볼 수도, 강사로 볼 수도, 아들로 볼 수도
    
    Polymorphism(다형성):
    
    Inheritance(상속):
    
    Encapsulation(데이터 은닉과 보호):
    
- 객체란?
    
    주체가 아닌 것, 주체(나)가 활용하는 것
    
    우리 주변에 있는 모든 것으로 프로그래밍의 대
    
- 객체지향 프로그래밍의 장점
    - 블록 형태의 모듈화된 프로그래밍
        
        신뢰성 높음
        
        추가/수정/삭제 용이
        
        재사용성 높음
        
- 현실 세계 객체, 클래스, 프로그램의 객체(instance, object)의 관계
    
    현실 객체가 갖는 속성과 기능은 추상화되어 클래스에 정의됨
    
    클래스는 구체화되어 프로그램의 객체가 됨
    
    **설계도**는 하나의 **종류( Type)**이 되고 설계도를 통해 나온 **제품**을 **객체**라고 부르며 주체가 사용
    
    붕어빵 틀 = Type 규정, 붕어빵 = 객체
    
- 추상화와 구체화
    
    ![image.png](image.png)
    
- 객체 생성과 메모리 할당
    - meta-space
        
        클래스 정보 처리
        
        타입, 필드, 메서드 정보, 상수 풀
        
    - stack
        
        메서드들의 실행 공간
        
        thread 별로 별도 관리
        
    - heap
        
        객체를 저장하기 위한 영역
        
        thread에 의해 공유
        
        객체가 생성되고 G.C에 의해 정리됨
        
        ![image.png](image%201.png)
        
        중요
        
        ![image.png](image%202.png)
        

### 2. 변수

- 종류
    - 타입에 따른 분류
        
        Primitive Type: 기본 8가지 타입 (int, char, float…)
        
        Reference Type: 나머지 모든 것 (String, int[], Person…)
        
    - 선언 위치에 따른 분류
        
        멤버 변수 - 클래스 영역 - 클래스 멤버 변수, 인스턴스 멤버 변수
        
        지역 변수 - 함수 내부 / 선언부 - 지역 변수 / 파라미터 변수
        
- 인스턴스 멤버 변수의 특징
    - 선언 위치: 클래스 { } 영역
    - 생성: 객체가 만들어질 때 heap에 객체 별로 생성
    - 초기화: default 초기화 이후 할당된 값으로 명시적 초기화
    - 접근: 객체 생성 후(메모리에 올린 후) 객체 이름으로 접근
    - 객체를 만들 때마다 객체 별로 생성 → 객체마다 고유한 변수 값 유지
        
        ```java
        Person person1 = new Person();
        person1.name = "홍길동";
        
        Person person2 = new Person();
        person2.name = "임꺽정";
        ```
        
    - 소멸 시점: G.C에 의해 객체가 없어질 때 (프로그래머가 소멸시킬 수 X)

- 클래스 멤버 변수의 특징
    - 선언 위치: 클래스 { } 영역 내 static 키워드
    - 생성: 클래스가 로딩될 때 구성 - heap 영역에 값 저장
    - 개별 객체의 생성과 무관하며 모든 객체가 공유 (공유 변수)
    - 접근: 객체 생성과 무관하게 클래스 이름으로 접근
        
        ```java
        public class Person {
        	static String scientificName = "Homo Sapeins";
        	String name;
        }
        
        Person p = new Person();
        p.scientificName = "객체를 통한 변경";
        // 객체 이름으로 접근 가능하나 부합하지 않음
        
        Person.scientificName = "클래스를 통한 변경";
        ```
        
    - 소멸 시점: 클래스가 언로드 될 때 함께 제거됨

- 지역 변수 & 파라미터 변수
    - 선언: 클래스 영역 { } 이외의 모든 중괄호 안에 선언되는 변수들
        - 메서드, 생성자, 초기화 블록
            
            ```java
            void call(String to) {          // 파라미터 변수
            	String beep = "띠";           // 로컬 변수
            	
            	for (int i = 0; i < 3; i++) { // 로컬 변수
            		System.out.println(beep);
            		}
            	}
            ```
            
    - 생성: 선언된 라인이 실행될 때
        - 생성 메모리 영역: stack의 메서드 프레임 내부
    - 초기화: 사용 전 명시적 초기화 필요
    - 접근: 외부에서는 접근 불가하므로 소속 불필요, 내부에서는 이름에 바로 접근
    - 소멸 시점: 선언된 영역 { }을 벗어날 때

![image.png](image%203.png)

### 3. 메서드

- 선언부
    - 리턴 타입
        
        아무것도 리턴하지 않을 경우 void
        
        결과 받을 때 묵시적 형 변환 적용
        
        리턴 타입은 하나만 적용 가능
        
    - 파라미터 전달 시 묵시적 형변환 적
    - 메서드 선언 시 동일 타입 인자가 몇 개 들어올지 예상 불가능한 경우
        
        → …을 이용해 파라미터 선언하면 호출 시 넘겨준 값의 개수에 따라 자동으로 배열 생성 및 초기화
        
        ![image.png](image%204.png)
        

- 구현부
    
    중괄호 내에서 처리해야 하는 비즈니스 로직 작성
    
    마지막에는 리턴 타입에 해당하는 값을 return문과 함께 반환해야 함
    
    - void는 생략 가능
    - 조건문 이용해서 리턴할 경우 모든 조건에서 return 필요

- 클래스 멤버와 인스턴스 멤버 간의 참조와 호출
    - 가장 중요한 것은 호출하려는 멤버가 메모리에 있는가?
    - static member → 언제나 메모리에 있음
        - 같은 클래스: 바로 호출
        - 다른 클래스: 클래스_이름.멤버_이름
    - instance member → 객체 생성 전에는 메모리에 없음
        - 같은 클래스: 바로 호출
        - 다른 클래스: 객체_이름.멤버_이름
        
        ![image.png](image%205.png)
        

- **메서드 호출 스택**
    - 스택(stack)
        
        First in Last out
        
        - 각각의 메서드 호출 시마다 메모리 상자 하나씩 할당
        - 메모리 상자를 쌓음
        - 언제나 맨 위에 있는 메모리 상자만 활성화
        - 이때 다른 메서드는 동작이 끝나지 않고 잠시 정지된 상태
        
        ![image.png](image%206.png)
        

- **기본형 변수와 참조형 변수**
    
    메서드 호출 시 파라미터로 입력된 값을 **복사**해서 전달
    
    ![이해 덜 됨 다시 보기 ](image%207.png)
    
    이해 덜 됨 다시 보기 
    

- **메서드 오버로딩**
    
    overloading: 추가 적재. 동일한 기능을 수행하는 메서드의 추가 작성
    
    eatUsingChopsticks, eatUsingFork, eatUsingSpoon
    
    - **장점**
        
        기억해야 할 메서드가 감소하고 중복 코드에 대한 효율적 관리 가능
        
    

### 4. 생성자

new 키워드와 함께 호출하는 것

메서드와 비슷하나 리턴 타입 없고 이름은 클래스 이름과 동일

- **생성자의 종류**
    - 기본 생성자
        
        파라미터가 없고 구현부가 비어 있는 형태
        
        명시적 생성자가 없을 때 컴파일러가 제공
        
    - 파라미터가 있는 생성자
        
        주의! 명시적 생성자를 만들면 기본 생성자는 추가되지 않음
        
        ```java
        public class ParameterPerson {
        	String name;
        	int age;
        	boolean isHungry;
        	
        	// 생성자의 역할: member 변수의 초기화...
        	
        	ParameterPerson(String n, int a, boolean i) {
        		name = n;
        		age = a;
        		isHungry = i;
        	}
        	
        	public static void main(String[] args) {
        		ParameterPerson person = new ParameterPerson("홍길동", 10, true);
        		
        		ParameterPerson p2 = new ParameterPerson(); // 기본 생성자 X
        		}
        	}
        ```
        

- **this**
    
    참조 변수로서 객체 자신을 가리킴
    
    this를 통해 자신의 멤버에 접근 가능
    
    - 용도
        
        로컬 변수와 멤버 변수의 이름이 같을 때 멤버 변수임을 명시적으로 나타냄
        
    - this는 객체에 대한 참조
        
        → static 영역에서는 사용 불가
        
        ![image.png](image%208.png)
        

- this()
    
    생성자도 오버로딩 가능
    
    반드시 첫 줄에서만 호출 가능
    

```java
package com.ssafy.day02.a_person;

public class Person {
	String name;
	int age;
	boolean isHungry;
	
	// 생성자도 오버로딩 가능
	Person() {
		this("성춘향", 20, false);
	}
	
	// 파라미터 생성자 추가
	Person(String name, int age, boolean isHungry) {
		this.name = name;
		this.age = age;
		this.isHungry = isHungry;
	}
	
	void eat() {
		System.out.println("냠냠");
		isHungry = false;
	}
	
	void work() {
		System.out.println("열심");
		isHungry = true;
	}
	
	void printInfo() {
		System.out.println("이름: " + name + ", 나이? " + age + ", 배고파요? " + isHungry);
	}
}

```

```java
package com.ssafy.day02.a_person;

public class PersonTest {
	public static void main(String[] args) {
		Person p = new Person("홍길동", 20, true);
		//p.name = "홍길동";
		//p.age = 20;
		//p.isHungry = true;
		
		p.printInfo();
		p.eat();
		p.printInfo();

		Person p2 = new Person("임꺽정", 0, false);
		//p2.name = "임꺽정";
		p2.printInfo();
		
		p = new Person();
		p.printInfo();
	}
}

```

### Appendix: 초기화 블록

생성자처럼 멤버 변수의 초기화 목적

- { }를 이용해 내부에 실행 코드 작성
- 이름 없고 별도로 호출할 수 없고 파라미터 못 받음

- **종류**
    - **클래스 초기화 블록**
        
        클래스 멤버 변수 초기화에 사용
        
        클래스 로딩 시 1회 호출
        
        <aside>
        
        클래스 로딩 → 클래스 초기화 블록
        
        </aside>
        
    - **인스턴스 초기화 블록**
        
        인스턴스 멤버 변수 초기화에 사용
        
        생성자 코드보다 먼저 호출됨
        
        객체 생성 시마다 1회 호출 
        
        <aside>
        
        객체 생성 → new 사용 → 인스턴스 초기화 블록 → 생성자 코드 
        
        </aside>