# Java - 컬렉션1

# Collection Framework

## **핵심 인터페이스**

- List: 순서 있고 중복 있음
    
    ex) ArrayList, LinkedList
    
- Set: 순서 없고 중복 없음
    
    ex) HashSet, TreeSet
    
- Map: key-value의 쌍으로 데이터 관리, 순서 없음, key 중복 불가, value 중복 가능
    
    ex) HashMap, TreeMap
    

## 1. List 계열

### 특징

순서 있고 중복 있음

![관련 클래스 관계도](image.png)

관련 클래스 관계도

### 주요 메서드

위치(index) 기반 메서드

- 추가: add

### 배열과 ArrayList

**배열의 장점**

- 간단하고 사용이 쉬우며 접근 속도가 빠름

**배열의 단점**

- 크기 변경
- 추가 데이터를 위해 새로운 배열을 만들고 복사해야 함
- 비순차적 데이터 추가, 삭제에 많은 시간이 걸림

ArrayList도 배열의 장단점을 그대로 가져감!

### LinkedList

각 요소를 Node로 정의하고 Node는 다음 요소의 참조값과 데이터로 구성됨

각 요소가 다음 요소의 링크 정보를 가지며 연속적 구성 필요 X

### LinkedList vs ArrayList

**ArrayList**: 순차 CRUD 및 조회 빠름

**LinkedList**: 비순차 CRUD 빠름

소량의 데이터를 가지고 사용할 경우 큰 차이가 없음

정적 데이터 활용, 단순 데이터 조회용 → ArrayList

동적 데이터 추가, 삭제가 많은 작업 → LinkedList

### 자료 삭제 시 주의사항

- index 이용한 for문
    
    요소가 삭제되면 size가 줄어들기 때문에 **index 차감 필요**
    
    거꾸로 접근하면 해결
    
- forEach 문장은 Collection 크기가 **불변**해야 함
    
    ```java
    public class ForEachTest {
    
        public static void main(String[] args) {
            List<Integer> nums = new ArrayList<>();
            for (int i = 0; i < 10; i++) {
                nums.add(i);
            }
    
            System.out.println("시작\t: " + nums);
    
            // 다음 iteration에서 nums의 개수가 변경되면 오류
            for (Integer num : nums) {
                if (num % 2 == 0) {
                    nums.add(num * num);
                    nums.remove(num);
              }
            }
        }
    }
    
    // Exception in thread "main" java.util.ConcurrentModificationException
    ```
    

### Collection과 Generic

```java
Object[] arr2 = new Person[3]; // 가능
List<Object> list = new ArrayList<Person>(); // 불가
```

## 2. Set 계열

### 특징

순서 없고 중복 없음

위치가 없기 때문에 update도 없음

![image.png](e2c5cbae-6df9-4c35-a03c-5ec5b2870ba6.png)

### 동일한 데이터의 기준

equals가 true를 리턴 && hashCode() 같음

```java
package com.ssafy.day07.b_set;

 public class SmartPhone {
    String number;

    public SmartPhone(String number) {
        this.number = number;
    }

    public String toString() {
        return "전화 번호: " + number;
    }

    // TODO: 동일한 번호의 SmartPhone이면 하나만 추가될 수 있도록 처리하시오.
    @Override
    public boolean equals(Object obj) {
    	if (obj instanceof SmartPhone p) {
    		return this.number.equals(p.number);
    	}
    	return false;
    } // 이것만으로는 구분 못 함!
    
    @Override
    public int hashCode() {
    	return number.hashCode(); // number가 같으면 hashCode도 같음
    }
    // END
}

package com.ssafy.day07.b_set;

import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;

public class SetTest {
    Set<Object> hset = new HashSet<Object>();

    private void addMethod() {
        hset.add(Integer.valueOf(1));
        hset.add("Hello");
        hset.add("Hello"); // 동일한 데이터 추가 확인
        hset.add(1); // 기본형은 wrapper를 통해 추가
        // TODO: SmartPhone 타입의 객체를 추가해보자.
        hset.add(new SmartPhone("010"));
        hset.add(new SmartPhone("010"));
        // END
        System.out.println("데이터 추가 결과: " + hset);
    }

    private void retrieveMethod() {
        // TODO:hset에서 필요한 정보를 조회해보자.
    	System.out.println(hset.contains("Hello"));
    	
    	for (Object obj : hset) {
    		System.out.println(obj);
    	}
        // END
    }

    private void removeMethod() {
        // TODO:hset에서 hello를 삭제해보자.
    	hset.remove("Hello");
        // END
        System.out.println("데이터 삭제 결과: " + hset);
    }

    public static void main(String[] args) {
        SetTest test = new SetTest();
        test.addMethod();
        test.retrieveMethod();
        test.removeMethod();
    }
}
```

## 3. Map 계열

### 특징

key와 value를 하나의 Entry로 묶어서 데이터 관리

- Key: Object 형태로 데이터 중복 X
- Value: Object 형태로 데이터 중복 O

![image.png](image%201.png)

### 주요 메서드

**추가**: put

**조회**: containsKey, containsValue, entrySet, keySet, get(Object Key), values

**삭제**: clear, remove

**수정**: put // 추가와 같으니 주의

```java
package com.ssafy.day07.c_map;

import java.util.HashMap;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;

public class MapTest {
    Map<String, String> hMap = new HashMap<>();

    private void addMethod() {
        System.out.println("추가 성공?: " + hMap.put("andy", "1234"));
        // 동일한 키의 사용 결과는?
        System.out.println("추가 성공?: " + hMap.put("andy", "4567"));
        hMap.put("kate", "9999");
        // 기존에 해당 키에 대한 값이 없을 때만 추가하기
        hMap.putIfAbsent("kate", "1234");

        hMap.put("henry", "4567"); // 동일한 값

        hMap.put("hong", "1234");
        System.out.println("추가 결과: " + hMap);
    }
    
    /*
     * 추가 성공?: null
     * 추가 성공?: 1234
     * 추가 결과: {hong=1234, henry=4567, kate=9999, andy=4567}
     */

    private void retrieveMethod() {
        // TODO: kate의 전화번호가 있나요?
    	System.out.println(hMap.get("kate"));
        // END

        // TODO: map이 가지고 있는 key와 거기에 연결된 value를 출력하시오.
    	Set<String> keys = hMap.keySet();
    	for (String k : keys) {
    		System.out.println(k + " : " + hMap.get(k));
    	}
    	
    	Set<Entry<String, String>> entries = hMap.entrySet();
    	for (Entry<String, String> e : entries) {
    		System.out.println(e.getKey() + " : " + e.getValue());
    		
    		if (e.getValue().equals("4567")) {
    			System.out.println("4567인 사람의 이름은... " + e.getKey());
    		}
    	}
        // END

        // TODO: 값이 4567인 사람의 이름은?
        // END
    }

    private void removeMethod() {
        // TODO: andy의 자료를 삭제하고 출력하시오.
    	hMap.remove("andy");
    	hMap.clear();
        // END
    }

    public static void main(String[] args) {
        MapTest hmt = new MapTest();
        hmt.addMethod();
        hmt.retrieveMethod();
        hmt.removeMethod();
    }
}
```

## 4. 정렬

특정 기준에 따라 요소의 크기를 비교하여 내림차순 또는 오름차순으로 배치하는 것

### **정렬 가능한 Collection**

- 배열, List 계열
- Set 中 SortedSet 계열
- Map 中 SortedMap 계열 (Key 기준)

**언제나 정렬 가능한 요소들**: String, Integer

### List<T>의 정렬

Collections.sort(List<T> list)

### Comparable

```java
package com.ssafy.day07.b_set;

// TODO: SmartPhone이 다른 SmartPhone과 번호를 기준으로 비교 가능하게 처리하시오.
 public class SmartPhone implements Comparable<SmartPhone> {
	 @Override
	public int compareTo(SmartPhone o) {
		return this.number.compareTo(o.number); // 오름차순
		// return this.number.compareTo(o.number); // 내림차순
	}
    // END

    String number;

    public SmartPhone(String number) {
        this.number = number;
    }

    public String toString() {
        return "전화 번호: " + number;
    }
}

public class ListSortTest {

    private List<String> names = Arrays.asList("Hi", "Java", "World", "Welcome");

    public void basicSort() {
        // TODO: names를 이름의 오름차순, 또는 그 역순으로 정렬해서출력하시오.
    	Collections.sort(names);
    	System.out.println(names);
    	Collections.reverse(names);
    	System.out.println(names);
    	// END
    }
    
    /*
     * [Hi, Java, Welcome, World]
     * [World, Welcome, Java, Hi]
     */

    public void sortPhone() {
        // TODO: 전화 번호에 따라 SmartPhone을 정렬해보자.
    	SmartPhone s1 = new SmartPhone("5");
    	SmartPhone s2 = new SmartPhone("0");
    	SmartPhone s3 = new SmartPhone("3");
    	List<SmartPhone> ps = Arrays.asList(s1, s2, s3);
    	Collections.sort(ps);
    	System.out.println(ps);
        // END
    }

    public static void main(String[] args) {
        ListSortTest st = new ListSortTest();
        st.basicSort();
        st.sortPhone();
    }
}
```

### Comparator의 활용

객체가 Comparable을 구현하고 있지 않거나 사용자 정의 알고리즘으로 정렬하려는 경우

```java
package com.ssafy.day07.d_etc.sort;

import java.util.Comparator;

public class StringLengthComparator implements Comparator<String> {
	
	@Override
	public int compare(String o1, String o2) {
		return Integer.compare(o1.length(), o2.length());
	}
}

public class ListSortTest {
    private List<String> names = Arrays.asList("Hi", "Java", "World", "Welcome");
    
    public void stringLengthSort() {
        // TODO: 문자열의 길이에 따라 names를 정렬해보자.
	    	Collections.sort(names, new StringLengthComparator());
        // END
        System.out.println(names); // [Hi, Java, World, Welcome]
    }

    public static void main(String[] args) {
        ListSortTest st = new ListSortTest();
        st.stringLengthSort();
    }
}
```

1회성 객체 사용 시 anonymous inner class 사용

- 람다 표현식
    
    ```java
        public void stringLengthSort() {
        
        	Collections.sort(names, (o1, o2) -> {
        		return Integer.compare(o1.length(), o2.length());
        	});
    ```