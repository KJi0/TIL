# Java - 제네릭

# 1. Generic

**Generics: 포괄적인, 통칭의**

다양한 타입의 객체를 다루는 메서드, 컬렉션 클래스에서 컴파일 시에 타입 체크

미리 사용할 타입을 명시해서 형 변환을 하지 않아도 되게 함 → 안정성 향상 및 번거로움 감소

## Generic Type

클래스 또는 인터페이스 선언 시 <>에 “타입 파라미터” 표시

### 형 인자 (Type Parameter)

단순히 임의의 참조형 타입을 말하며 성격에 따라 선언

- T: reference Type
- E: Element
- K: Key
- V: Value

### 객체 생성

변수 쪽과 생성 쪽의 타입은 반드시 같아야 함 (상속 관계 등 X)

## 클래스에 선언된 Generic

무언가를 담는 Box 생성

**컴파일 타임**에 타입 파라미터들이 **대입된 타입으로 대체**됨

```java
package com.ssafy.day06.a_generic.box;

// Object를 속성으로 사용 -> 어떤 객체든지 수용 가능
public class NormalBox {
	private Object some;
	
	public NormalBox() {}
	
	public NormalBox(Object some) {
		this.some = some;
	}
	
	public Object getSome() {
		return some;
	}
	
	public void setSome(Object some) {
		this.some = some;
	}
}

// "어떤 타입"을 속성으로 사용 -> 타입 선언 시 결정
public class GenericBox<T> {
private T some;
	
	public GenericBox() {}
	
	public GenericBox(T some) {
		this.some = some;
	}
	
	public T getSome() {
		return some;
	}
	
	public void setSome(T some) {
		this.some = some;
	}
}
```

## 주의사항

1. raw type의 사용과 @SuppressWarning
    
    ```java
    // @SuppressWarning 남발하면 안 좋음
    @SuppressWarnings({"rawtypes", "unused"})
    GenericBox box = new GenericBox();
    ```
    
2. 헷갈리는 사용법
    
    ```java
    // pbox는 Person 타입을 담을 수 있음, 상속 관계 X
    public void confusing() {
    	GenericBox<Person> pbox = new GenericBox<>();
    	pbox.setSome(new Person());
    	pbox.setSome(new SpiderMan());
    	
    	// pbox = new GenericBox<SpiderMan>();
    ```
    
3. 타입 파라미터는 인스턴스 레벨에서 결정됨
    
    → 클래스 레벨의 static 멤버에서는 사용할 수 없음
    
4. 제네릭은 컴파일 타임에 지정한 타입으로 존재
    
    → 런타임에는 타입 정보 소거 (Type Erasure: 단순 Object로 관리)
    
    ```java
    public void cantUseGeneric() {
          //I i = new I();//Cannot instantiate the type I
    
          GenericBox<SpiderMan> obj = new GenericBox<>();
    
          // compile error : Type Object cannot be safely cast to GenericBox<String>
          //if(obj instanceof GenericBox<String>) {  }
    
          if (obj instanceof GenericBox gb) {
              gb.setSome("Hello"); // 타입에 안전하지 않음
              System.out.println("맞지만 타입에 안전하지 않음: " + gb.getSome());
          }
    
          // ?는 wild card라고 함. 타입 확인용, 변환은 안 됨
          // 타입이 확인 안 되니 아무것도 넣지 못하게 막는 거?
          if (obj instanceof GenericBox<?> gb) {
              // gb.setSome("Hello"); // compile error
              System.out.println("이것이 최선: 타입이 훼손될 일은 없다!");
          }
      }
    ```
    
5. Generic 타입의 배열 생성 불가
6. raw 타입 객체의 형 변환 주의
    
    실제 메모리에는 모든 객체를 담을 수 있으므로 형이 보장되지 못함
    

## 한정형 형인자(bounded type parameter)

필요에 따라 구체적인 타입 제한 필요

- 계산기 프로그램 구현 시 Number 이하의 타입(Byte, Short, Integer…)로만 제한
    
    type paramter 선언 뒤 extends와 함께 상위 타입 명시
    

## Generic Method

파라미터와 리턴 타입으로 type parameter를 갖는 메서드

메서드 리턴 타입 앞에 타입 파라미터 변수 선언

```java
public class TypeParameterMethodTest<T> {
    T some;

    public TypeParameterMethodTest(T some) {
        this.some = some;
    }

    public <P> P method(P p) {
        System.out.printf("클래스 레벨의 T: %s%n", some.getClass().getSimpleName());
        System.out.printf("파라미터 레벨의 P: %s%n", p.getClass().getSimpleName());
        return p;
    }

    public static void main(String[] args) {
        // 객체 생성 시점 - 클래스에 선언된 타입 파라미터 T의 타입 결정
        TypeParameterMethodTest<String> tpmt = new TypeParameterMethodTest<>("Hello");
        // 메서드 호출 시점 - 메서드에 선언된 타입 파라미터 P의 타입 결정
        tpmt.<Long>method(20L); // 명시적으로 타입 결정
        tpmt.method(10);        // 묵시적으로 타입 결정
    }
}
```

## 와일드 카드(?) 자료형

제네릭 타입 변수 선언 시 실제 타입 파라미터가 무엇인지 모르거나 신경 쓰고 싶지 않을 경우

![우선 super, extends 개념만 알아 두자!!](image.png)

우선 super, extends 개념만 알아 두자!!

- **예제 코드**
    
    ```java
    package com.ssafy.day06.a_generic.wild;
    
    import com.ssafy.day03.a_inheritance.person.Person;
    import com.ssafy.day03.a_inheritance.person.SpiderMan;
    import com.ssafy.day06.a_generic.box.GenericBox;
    
    public class WildTypeTest {
        public void boxCallTest() {
            GenericBox<Object> boxObject = new GenericBox<>();
            GenericBox<Person> boxPerson = new GenericBox<>();
            GenericBox<SpiderMan> boxSpiderMan = new GenericBox<>();
    
            //notUseWildCardType(boxObject);
            notUseWildCardType(boxPerson);
            //notUseWildCardType(boxSpiderMan);
    
            // TODO: useWildCardType{n} 메서드를 호출하면서 위 3가지 변수들을 넘겨보자.
            // 1은 다 가능, 2는 obj 불가, 3은 spiderman 불가
            useWildCardType1(boxObject);
            useWildCardType1(boxPerson);
            useWildCardType1(boxSpiderMan);
            // END
        }
    
        public void notUseWildCardType(GenericBox<Person> boxPerson) {
        }
    
        public void useWildCardType1(GenericBox<?> boxAll) {
            // TODO: boxAll에 담을 수 있는 무언가를 담고 빼보자.
        	// boxAll.setSome(new Object()); // 못 넣음!! 여기 넣을 수 있는 건 오로지 NULL => set 용도 X
        	Object obj = boxAll.getSome(); // 꺼낼 순 있지만 타입 체크가 필요함 -> 번거로움
            // END
        }
    
        public void useWildCardType2(GenericBox<? extends Person> boxExtendsPerson) {
            // TODO: boxExtendsPerson에 담을 수 있는 무언가를 담고 빼보자.
        	// boxExtendsPerson.setSome(new Person()); // 못 넣음! set 용도 X
        	Person p = boxExtendsPerson.getSome(); // 형변환 없이 최소한 Person으로 쓸 수 있음 => get 용도
            // END
        }
    
        public void useWildCardType3(GenericBox<? super Person> boxSuperPerson) {
            System.out.println(boxSuperPerson.getClass());
            // TODO: boxSuperPerson에 담을 수 있는 무언가를 담고 빼보자.
            boxSuperPerson.setSome(new SpiderMan()); // Person과 그 자식 다 가능 => set 용도
            Object obj = boxSuperPerson.getSome(); // 모두 Object의 자식, 자손
            // END
        }
    
        public static void main(String[] args) {
            WildTypeTest wtt = new WildTypeTest();
            GenericBox<Object> boxObject = new GenericBox<>();
            GenericBox<Person> boxPerson = new GenericBox<>();
            GenericBox<SpiderMan> boxSpiderMan = new GenericBox<>();
    
            wtt.useWildCardType3(boxPerson);
    
            boxPerson.setSome(new SpiderMan());
    
        }
    }
    
    ```
    

### PECS

**Producer Extends:** 제네릭 타입이 데이터를 생산해 외부로 공급

**Consumer Super:** 제네릭 타입이 데이터를 소비

```java
// src가 공급해 준 데이터를 dest가 소비하는 구조
public class Collections {
	pulbic static <T> void copy(List<? super T> dest, List<? extends T> src) {
	...
	}
}
```

### Generic Type 객체 할당받을 때 와일드 카드 이용

ㅈㄴ 뭔 소린지 모르겠음 복습해야 함

![image.png](image%201.png)

# 2. enum

열거형 데이터 타입

데이터가 몇 가지 한정된 값(주로 상수)만을 갖는 형태 ex) 요일, 월, 계절 등

java.lang.Enum을 내부적으로 상속받은 형태의 특별한 클래스

## Enum 타입 작성

```java
enum Grade {
	SALES, PART_TIME_JOB, NORMAL
}
```

Enum 타입에 선언된 내용은 enum 상수로 불림

## Enum 타입의 사용

클래스와 동일하게 선언하며 할당될 수 있는 값은 **enum 상수, null**로 한정

```java
private void useEnum(Grade grade) {
  	 if (grade.equals(SALES)) {
           System.out.println("영업 실적 반영");
       } else if (grade.equals(PART_TIME_JOB)) {
           System.out.println("근무 시간 반영");
       } else if (grade.equals(NORMAL)) {
           System.out.println("근로 계약 기준");
       }
   }
```

## Enum을 이용한 연산

**비교 연산**에서 주로 사용

- ==, equals: 두 개의 enum 상수 값이 같은지 비교

> 객체 비교는 무조건 equals!
> 

## Enum의 주요 메서드

![image.png](image%202.png)

name: enum 상수의 이름

ordinal: enum 상수의 순서

# 3. annotation

컴파일러, JVM, 프레임워크 등이 보는 주석

소스코드에 메타 데이터 삽입하는 형태

## 선언

interface 선언과 유사하게 @interface 사용

```java

```

## 메타 에너테이션

에너테이션 설정을 위한 에너테이션

- @Documented: Javadoc 만들 때
- @Inherited: 애너테이션이 하위 클래스에 상속됨
- @Repeatable: 반복해서 적용될 수 있는지 표시

- @Retention: 어느 단계까지 에너테이션 정보를 유지할 것인가?
    
    
    | 이름 | 범위 | 예 |
    | --- | --- | --- |
    | SOURCE | 컴파일러 | @Override
    @SuppressWarnings |
    | CLASS | 클래스 (생략 시 기본) |  |
    | RUNTIME | 컴파일 시 포함, 리플렉션 | @Deprecated |
- @Target: 에너테이션을 어디에서 사용할 수 있는가?

![image.png](image%203.png)

## 속성

**추상 메서드처럼 선언**

- 메서드 이름 → 속성명, 리턴 타입 → 속성 타입

**일반 속성처럼 ‘키=값’으로 사용**

- 배열은 {}를 쓰는데 길이가 1일 때는 생략 가능
- 속성은 default 값을 가질 수 있으며 이 경우 속성 설정 생략 가능
- 속성이 value 하나일 경우 속성 생략 가능

```java
package com.ssafy.day06.c_annotation;
import java.util.Arrays;

import com.ssafy.day03.a_inheritance.person.Person;
import com.ssafy.day06.a_generic.box.GenericBox;

public class AnnotationTest {

    private String[] blackList;

    // TODO: 다음의 생성자를 deprecated 시켜보자.
    @Deprecated(since = "2.5.1", forRemoval = true)
    public AnnotationTest() {
        blackList = new String[] { "hello", "java", "world" };
    }

    // END

    public AnnotationTest(String[] list) {
        this.blackList = list;
    }

    public static void main(String[] args) throws Exception {
        // TODO Auto-generated method stub
        AnnotationTest at = new AnnotationTest();
        Person p = at.createInstance(Person.class);
        System.out.println(p);
    }

    // TODO: 다음 메서드에서 발생하는 warning들을 억눌러보자.
    @SuppressWarnings(value = {"rawtypes"})
    // @SuppressWarnings({"rawtypes"}) // value 1개이므로 생략 가능
    // @SuppressWarnings("rawtypes") // // 길이가 1이므로 생략 가능
    public <T> T createInstance(Class<T> clazz) throws Exception {
        GenericBox box = new GenericBox();
        
        Object obj = clazz.getDeclaredConstructors()[0].newInstance();
        return (T)obj;
    }

    // END

    // TODO: 다음 메서드가 잘 재정의되었는지 확인해보자.
    @Override
    public String toString() {
        return "black list: " + Arrays.toString(blackList);
    // END
}
```