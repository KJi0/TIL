# Java - 다형성

## 1. encapsulation

데이터 은닉과 보호

외부에서 변수에 직접 접근하지 못하게 보호하기 위한 대책

- 변수를 private 접근으로 막기
- 공개되는 메서드를 통한 접근 통로 마련: setter / getter

```java
package com.ssafy.day04.a_encapsulation;

class BelievableUserInfo {
    // 이름은 null이 될 수 없음.
    private String name = "홍길동";

    // 계좌는 0보다 커야 함.
    private int account = 10000;

    // TODO: name 과 account에 부적절한 값이 할당되지 못하도록 처리하시오.
    //  name과 account 는 private으로 변경되어야 한다.
    public String getName() {
    	return this.name;
    }
    
    public void setName(String name) {
    	if (name != null) {
    		this.name = name;
    	} else {
    		System.out.println("name은 필수!!!");
    	}
    }

	public int getAccount() {
		return account;
	}

	public void setAccount(int account) {
		if (account >= 0) {
			this.account = account;
		} else {
			System.out.println("마통 안돼!!");
		}
	}
	
	// END
}

public class BelievableTest {
    public static void main(String[] args) {
        BelievableUserInfo info = new BelievableUserInfo();
        System.out.printf("사용자 정보:%s, %d%n", info.getName(), info.getAccount());
        info.setName(null);
        info.setAccount(-1000);
        System.out.printf("사용자 정보:%s, %d%n", info.getName(), info.getAccount());
    }
}
```

### **객체의 생성 제어와 Singleton 디자인 패턴**

- 객체의 생성을 제한해야 한다면?
    - 여러 개의 객체가 필요 없는 경우
        
        객체를 구별할 필요가 없는 경우 = 수정 가능한 멤버 변수가 없고 기능만 있는 경우
        
        이런 경우를 stateless한 객체라고 함
        
        - 어떤 경우에 객체를 구별할 필요가 없을까?
            
            

### **Singleton 디자인 패턴**

<aside>

**Singleton 패턴이란?** 클래스의 인스턴스를 단 하나만 생성하도록 제한하는 패턴

</aside>

- 작성법
    - 외부에서 생성자에 접근 금지
        - 생성자의 접근 제한자를 private 설정
    - 내부에서는 private 접근 가능하므로 생성자 호출 → 객체 생성
    - 외부에서 private member에 접근 가능한 getter 생성
    - 객체 없이 외부에서 접근할 수 있도록 getter와 변수에 static 추가

```java
package com.ssafy.day04.b_singleton;

class SingletonClass {
  // TODO:SingletonClass에 Singleton Design Pattern을 적용하시오.
	// singleton의 출발점: 외부에서 객체를 못 만들어야 한다.
	private SingletonClass() {}
	
	private static SingletonClass sc = new SingletonClass();
	
	public static SingletonClass getInstance() {
		return sc;
	}
  // END
  public void sayHello() {
    System.out.println("Hello");
  }

}

public class SingletonTest {
  public static void main(String[] args) {
    // TODO:SingletonClass를 사용해보세요.
	  SingletonClass sc1 = SingletonClass.getInstance();
	  SingletonClass sc2 = SingletonClass.getInstance();
	  
	  System.out.println(sc1 == sc2);
    // END
  }
}

```

## 2. polymorphism (다형성)

하나의 객체가 많은 타입을 가질 수 있는 성질

```java
package com.ssafy.day04.c_polymorphism;

import com.ssafy.day03.a_inheritance.person.Person;
import com.ssafy.day03.a_inheritance.person.SpiderMan;

public class PolymorphismUsage {
    public void useObjectArray() {
        // TODO:Object []을 선언하고 다양한 객체를 저장하고 저장된 클래스 타입을 출력하세요.

        // END
    }

    public void useObjectParam() {
        System.out.println(1);
        System.out.println("Hello");
        System.out.println(new Person());
        System.out.println(new SpiderMan());
    }

    public static void main(String[] args) {
        PolymorphismUsage usage = new PolymorphismUsage();
        usage.useObjectArray();
        usage.useObjectParam();
    }
    
    public void polyTest() {
    	SpiderMan onlyOne = new SpiderMan();
    	Person person = onlyOne;
    	Object obj = onlyOne;
    	System.out.println(onlyOne);
    }
}

```

## 3. 객체의 형 변환

![image.png](image.png)

메모리에 있는 것과 사용할 수 있는 것의 차이

```java
Person person = new SpiderMan();
// person은 isSpider나 fireWeb을 모름
```

### 참조형 객체의 형 변환

- 하위 타입을 상위 타입으로 형 변환 → 묵시적 캐스팅
    
    자손에서 조상: 형 변환 생략 가능
    
    ```java
    byte b = 10;
    int i = b;
    
    Person person = new Person();
    Object obj = person;
    ```
    
- 상위 타입을 하위 타입으로 형 변환 → 명시적 캐스팅
    
    조상에서 자손: 형 변환 생략 불가
    
    ```java
    int i = 10;
    byte b = (byte)i;
    
    Person person
    ```
    
    > 부모는 마음이 넓어서 모든 자식을 품을 수 있지만, 자식은 마음이 좁아 부모를 품을 수 없다!
    > 

- 조상을 무작정 자손으로 바꿀 수는 없다
    - instanceof 연산자
        
        실제 메모리에 있는 객체가 특정 클래스 타입인지 boolean으로 리턴
        
        ```java
        package com.ssafy.day04.c_polymorphism;
        
        import com.ssafy.day03.a_inheritance.person.SpiderMan;
        
        public class InstanceOfTest {
            private void unsafeCasting() {
            	Object o = new SpiderMan();
            	SpiderMan sman = (SpiderMan)o;
            	
            	// ClassCastException 발생
                Object obj = 1; // int ==> Integer
                String s = (String) obj;
                System.out.println(s.length());
            }
        
            private void safeCasting() {
                // TODO: 위 메서드가 안전하게 형 변환할 수 있도록 수정해보자.
            	Object obj = 1;
            	if (obj instanceof String s) {
            		System.out.println(s.length());
            	} else {
            		System.out.println("문자열 아님!!");
            	}
                // END
            }
        
            public static void main(String[] args) {
                InstanceOfTest instance = new InstanceOfTest();
                //instance.unsafeCasting();
                instance.safeCasting();
            }
        
        }
        
        ```
        

### 참조 변수의 레벨에 따른 객체의 멤버 연결

![sub, sub class method, super, sub class method](image%201.png)

sub, sub class method, super, sub class method

- **정적 바인딩(static binding)**
    
    컴파일 단계에서 참조 변수의 타입에 따라 연결이 달라짐
    
    상속 관계에서 객체의 멤버 변수가 중복될 때 또는 static method
    
- **동적 바인딩(dynamic binding)**
    
    다형성을 이용해서 메서드 호출이 발생할 때 runtime에 메모리의 실제 객체 타입으로 결정
    
    상속 관계에서 객체의 instance method가 재정의되었을 때 마지막에 재정의된 자식 클래스의 메서드가 호출됨
    
    ⇒ 가장 최적의 method
    

- 객체가 출력되는 과정
    
    객체가 출력되는 건 Object의 toString 때문!
    
    → 예쁘게 출력하기 위해 최적의 메서드로 재정의 필요
    
    ```java
    package com.ssafy.day03.a_inheritance.person;
    
    public class Person {
    	String name;
    	
    	public Person() {}
    	
    	public Person(String name) {
    		this.name = name;
    	}
    	
    	void eat() {
    		System.out.println("냠냠");
    	}
    	
    	void jump() {
    		System.out.println("폴짝");
    	}
    	
    	@Override
    	public String toString() {
    		return this.name;
    	}
    }
    
    ```
    
    ```java
    package com.ssafy.day03.a_inheritance.person;
    
    public class SpiderMan extends Person {
    	Spider spider; // has a
    	boolean isSpider;
    	
    	public SpiderMan() {};
    	
    	public SpiderMan(String name, Spider spider, boolean isSpider) {
    		super(name);
    		this.spider = spider;
    		this.isSpider = isSpider;
    	}
    	
    	public void fireWeb() {
    		if (this.isSpider) {
    			spider.fireWeb();
    		} else {
    			System.out.println("사람일 때는 안 되지.");
    		}
    	}
    	
    	@Override
    	public void jump() {
    		if (this.isSpider) {
    			spider.jump();
    		} else {
    			//System.out.println("폴짝");
    			super.jump();
    		}
    	}
    	
    	public void jump(int 도움닫기) {
    		System.out.println("일단 " + 도움닫기 + "까지 이동");
    		this.jump();
    	}
    	
    	@Override
    	public String toString() {
    		return super.toString() + " spider mode? " + this.isSpider;
    	}
    }
    
    ```
    
    ```java
    package com.ssafy.day04.c_polymorphism;
    
    import com.ssafy.day03.a_inheritance.person.Person;
    import com.ssafy.day03.a_inheritance.person.Spider;
    import com.ssafy.day03.a_inheritance.person.SpiderMan;
    
    public class PolymorphismUsage {
        public void useObjectArray() {
            // TODO:Object []을 선언하고 다양한 객체를 저장하고 저장된 클래스 타입을 출력하세요.
        	Object[] objs = new Object[4];
        	objs[0] = new Object();
        	objs[1] = new SpiderMan();
        	objs[2] = "hello";
        	objs[3] = 1;
        	
        	for (Object object : objs) {
        		System.out.println(object + ":" + object.getClass().getName());
        	}
        		// END
        }
    
        public void useObjectParam() {
            System.out.println(1);
            System.out.println("Hello");
            System.out.println(new Person("피터 파커"));
            System.out.println(new SpiderMan("피터 파커", new Spider(), true));
        }
    
        public static void main(String[] args) {
            PolymorphismUsage usage = new PolymorphismUsage();
            usage.useObjectArray();
            usage.useObjectParam();
        }
        
        public void polyTest() {
        	SpiderMan onlyOne = new SpiderMan();
        	Person person = onlyOne;
        	Object obj = onlyOne;
        	System.out.println(onlyOne);
        }
    }
    
    ```
    

![image.png](image%202.png)

상위 타입으로 올라갈수록 활용도도 높아지지만, 코드의 복잡성도 함께 증가

## 4. Object 메서드 재정의

### Object 클래스

가장 최상위 클래스로 모든 클래스의 조상

- toString()
- equals()
    
    두 객체가 같은지를 비교하는 메서드
    
    등가비교 연산자 ==로 두 객체의 주소값 비교
    
    - 두 개의 레퍼런스 변수가 같은 객체를 가리키고 있는가?
        
        ```java
        Object obj1 = new Object();
        Object obj2 = new Object();
        Object obj3 = obj2;
        
        System.out.printf("obj1 == obj2: %b%n", obj1 == obj2);
        System.out.print("obj1 equals obj2: %b%n", obj1.equals(obj2));
        ```
        
    
    > 객체의 주소 비교: ==
    객체의 내용 비교: equals 재정의
    > 

```java
package com.ssafy.day04.d_object;

import java.util.Objects;

public class Product {
    private String sn;

    public Product(String sn) {
        this.sn = sn;
    }

    // TODO: toString, equals, hashCode를 적절히 재정의해보자.
	@Override
	public String toString() {
		return "Product [sn=" + sn + "]";
	}

	@Override
	public boolean equals(Object obj) {
		if (obj instanceof Product p) {
			return this.sn.equals(p.sn);
		}
		return false;
	}
	
	@Override
	public int hashCode() {
		return sn.hashCode();
	}
    // END
}
```

```java
package com.ssafy.day04.d_object;

public class ProductTest {

    public static void main(String[] args) {
        Product product1 = new Product("123");
        Product product2 = new Product("123");

        System.out.println(product1);
        System.out.println(product1.equals(product2));
        System.out.printf("hashCode: %d, %d\n", product1.hashCode(), product2.hashCode());
    }
}
```

- hashCode()
    
    equals 메서드 재정의할 때는 반드시 hashCode도 재정의할 것
    
    HashSet, HashMap 등에서 객체의 동일성을 확인하기 위해 사용
    
    ![image.png](image%203.png)
    

## 강사님 부가설명

### 

```java
class Parent{
    public Parent() {
        System.out.println("부모 객체 생성");
    }
    public int no = 1;
    public String name = "Parent"; 
    
    public void hello() {
        System.out.println("Hello "+ name);
    }
    
    @Override
    public String toString() {
        return "부모 객체 입니다.";
    }
}

class Child extends Parent{
    public Child() {
        System.out.println("자식 객체 생성");
    }

    public String name = "Child"; //가능하지만 권장하지 않음.

    public  void run() {
        System.out.println("뜁니다.");
    }
    
    @Override
    public void hello() {
        System.out.println("Hello "+name);
    }
    
}

public class Test{
    public static void main(String[] args) {
        
        //부모 타입에 부모 구현체
        Parent pp = new Parent();
        //부모 타입에 자식 구현체
        Parent pc = new Child();
        //자식 타입에 자식 구현체
        Child cc = new Child();
        
        //각 변수에서 name 변수 값 찍어보기
        System.out.println(pp.name);
        System.out.println(pc.name);
        System.out.println(cc.name);
        
        //각 변수에서 toString() 메소드 접근해보기
        System.out.println(pp);
        System.out.println(pc.toString());
        System.out.println(cc.toString());
        
        //각 변수에서 hello() 메소드 접근해보기
        pp.hello();
        pc.hello();
        cc.hello();
        // run() 메소드에 접근해보기
        cc.run();
        
    }
}
```

1. meta-space에 Parent 클래스 변수 정보를 읽음 (no, name)
2. meta-space에 Parent vtable이 만들어지고 메서드 관련 정보(메모리 주소) 저장
    
    ex) hello()        0x100
    
    toString()  0x1112
    
    *vtable: 내가 호출할 메서드의 주소값을 저장한 테이블
    
3. meta-space에 Child 클래스 변수 정보 읽음 (name)
4. meta-space에 Child vtable이 만들어지고 메서드 읽음
    
    ex) hello()       0x2222 // 재정의함
    
    run()          0x2223
    
    toString() 0x1112   // 재정의 안 함
    
5. stack에서 Main 메서드 실행
6. heap에 Parent 구현체 구현
    1. 0x100에 만들어지면 stack에 저장되고 stack에서 heap 주소 가리킴
7. Child 구현체 구현 0x200
8. Child 구현체 구현 0x300
9. String Pool에 “Parent”, “Child” 들어가서 각 구현체 name에서 가리킴
10.  Parent 구현체에는 Object 필드, Parent 필드 있음
    1. 헤더에 Parent vtable 주소 있음
11. Child 구현체에는 Object, Parent, Child 필드 있음
    1. 헤더에 Child vtable 주소
12. pp.name → Parent name 찍음
13. pc.name → 구현체가 있고, 메모리에 있긴 하지만 내 “타입”은 Parent라서 Parent 범위까지밖에 못 봄
    1. 컴파일러가 접근하는 우선순위
        1. 데이터 타입
14. cc.name → Child로 범위가 늘어나서 Child name 찍음
15. 메서드 콜 하면 해당 구현체 헤더의 vtable 주소로 감
16. 오버라이딩 했으면 최적의 메서드로 접근! (동적 바인딩)
    1. 단, 실행되지 않은 컴파일러는 데이터 타입의 범위만 보임

![image.png](image%204.png)