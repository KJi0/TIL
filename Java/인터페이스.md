# Java - 인터페이스

# 1. abstract class

```java
package com.ssafy.day05.a_abstract;

public class Vehicle {
	private int curX, curY;

    public void reportPosition() {
        System.out.printf("차종: %s: 현재 위치: (%d, %d)%n", this.getClass().getSimpleName(), curX, curY);
    }

		// 이 코드가 동작 안 함! 그래서 지워 버리면? Override 문제 생김
    public void addFuel() {
        System.out.printf("연료가 필요하긴 하지.");
    }
}

// TODO: Vehicle을 상속받는 구조로 변경해보자.
 public class DieselSUV extends Vehicle {
    private int curX, curY;

    @Override
    public void addFuel() {
        System.out.printf("차종: %s: 연료 주입: %s%n", this.getClass().getSimpleName(), "경유");
    }
}

// TODO: Vehicle을 상속받는 구조로 변경해보자.
 public class ElectricCar extends Vehicle {
    private int curX, curY;

    @Override
    public void addFuel() {
        System.out.printf("차종: %s: 연료 주입: %s%n", this.getClass().getSimpleName(), "충전");
    }
}

public class VehicleTest {

  public static void main(String[] args) {
    // TODO: DieselSUV와 ElectricCar를 각각 한대씩 관리하는 배열을 만들고 사용해보자.
	  Vehicle[] vehicles = {new DieselSUV(), new ElectricCar()};
	  
	  for (Vehicle v : vehicles) {
		  v.addFuel();
		  v.reportPosition();
	  }
  }
}
```

### 추상 클래스 정의

자손 클래스에서 반드시 **재정의**해서 사용되기 때문에 **조상의 구현이 무의미**한 메서드

- 메서드의 선언부만 남기고 구현부는 세미콜론으로 대체
- abstract 키워드를 메서드 선언부에 추가
    
    ⇒ **abstract class**
    

### 추상 클래스 특징

- 상속 전용 클래스
    
    자식은 추상 메서드를 재정의할 책임
    
    객체 생성 불가하지만 자식을 참조는 가능 (다형성)
    
    UML 상에서 이탤릭으로 표현함
    
- 조상의 abstract 클래스를 상속받으려면?
    - abstract 메서드를 재정의
    - abstract 메서드를 재정의하지 않은 경우
        
        자식 클래스는 abstract 클래스로 선언되어야 함
        

```java
// Vehicle v = new Vehicle(); // abstract 클래스는 객체를 생성할 수 없음

Vehicle v = new DieselSUV(); // 자식을 참조하는 것은 문제 없음
```

```java
package com.ssafy.day05.a_abstract;

public abstract class Vehicle {
	private int curX, curY;

    public void reportPosition() {
        System.out.printf("차종: %s: 현재 위치: (%d, %d)%n", this.getClass().getSimpleName(), curX, curY);
    }

    public abstract void addFuel();
}
```

### 추상 클래스를 사용하는 이유

- abstract 클래스는 구현의 강제를 통해 프로그램의 안정성 향상
    
    ![image.png](image.png)
    
- interface에 있는 메서드 중 구현할 수 있는 메서드를 구현해 개발 편의 지원

# 2. Interface

서로 다른 두 시스템을 서로 이어 주는 장치

### 인터페이스 작성

- 최고 수준의 추상화 단계: 일반 메서드는 모두 abstract 형태
- 형태
    
    클래스와 유사하게 interface 선언
    
    모든 멤버 변수는 public static final이며 생략 가능
    
    모든 메서드는 public abstract이며 생략 가능
    
    ```java
    public interface MyInterface {
    	public static final int MEMBER1 = 10;
    	int MEMBER2 = 10;
    	
    	public abstract void method1(int param);
    	void method2(int param);
    ```
    

### 인터페이스 상속

클래스와 마찬가지로 extends로 상속 가능

클래스와 다른 점은 다중 상속이 가능

- (클래스는 왜 안 됐었지?) 헷갈릴 메서드 구현 자체가 없음

```java
package com.ssafy.day05.b_interface;

public interface Fightable {
	int fire();
}

public interface Transformable {
	void changeShape(boolean isHeroMode);
}

public interface Heroable extends Fightable, Transformable {
	void upgrade();
}
```

### 인터페이스 구현과 객체 참조

클래스에서 implements 키워드 사용해 인터페이스 구현

- implements 한 클래스는
    - 모든 abstract 메서드를 재정의해서 구현하거나
    - 구현하지 않을 경우 abstract 클래스로 표시해야 함
- 여러 개의 interface implements 가능
- 다형성은 조상 클래스 뿐만 아니라 조상 인터페이스에도 적용
- interface와의 관계도 is a 관계이지만 세부적으로 is able to라고도 함

```java
package com.ssafy.day05.b_interface;

public class IronMan implements Heroable {

	@Override
	public int fire() {
		System.out.println("빵야");
		return 0;
	}

	@Override
	public void changeShape(boolean isHeroMode) {
		System.out.println("짜잔");
	}

	@Override
	public void upgrade() {
		System.out.println("좋아짐");
	}
}

public class IronManTest {
	public static void main(String[] args) {
		IronMan iman = new IronMan();
		Object obj = iman;
		Heroable h = iman;
		Transformable t = iman;
		Fightable f = iman;
		// 다형성
	}
}
```

# 3. Interface의 필요성

- 구현의 강제로 표준화 처리 (abstract 메서드 사용)
- 손쉬운 모듈 교체 지원
    - 예시
        
        ```java
        package com.ssafy.day05.b_interface.module;
        
        // Inkjet 프린터가 고장났을 때 Lazer 프린터로 바꾸기
        public interface Printer {
            void print(String fileName);
        }
        
        public class InkjetPrinter implements Printer {
        
            @Override
            public void print(String fileName) {
                System.out.println("Inkjet Printer로 프린트 한다.");
            }
        }
        
        public class LazerPrinter implements Printer {
        
        	@Override
        	public void print(String fileName) {
        		System.out.println("Lazer Printer로 프린트 한다.");
        	}
        }
        
        public class PrintClient {
            private Printer printer;
        
            public void setPrinter(Printer printer) {
                this.printer = printer;
            }
        
            public void printThis(String fileName) {
                printer.print(fileName);
            }
        }
        
        public class PrinterTest {
        
            public static void main(String[] args) {
                PrintClient client = new PrintClient();
               
                // TODO: client가 LazerPrinter를 사용하도록 하고 클래스의 변화를 확인하시오.
                client.setPrinter(new LazerPrinter());
                // END
                client.printThis("myfile");
            }
        }
        ```
        
- 서로 상속의 관계가 없는 클래스들에게 인터페이스로 관계 부여해 다형성 확장
    - 예시
        
        ```java
        package com.ssafy.day05.b_interface.relation;
        
        // Chargable 인터페이스로 관계 부여
        public interface Chargeable {
            void charge();
        }
        
        // TODO: HandPhone를 충전 가능하게 설정하시오.
        public class HandPhone extends Phone implements Chargeable {
        
        	@Override
        	public void charge() {
        		System.out.println("핸드폰 충전");
        	}
        }
        
        // TODO: ElectricShaver를 충전 가능하게 설정하시오.
        public class ElectricShaver extends Shaver implements Chargeable {
        	@Override
        	public void charge() {
        		System.out.println("전기 면도기 충전");
        	}
        }
        
        public class RelationShipTest {
            public static void main(String[] args) {
                Object[] objs = { new HandPhone(), new Shaver(), new Phone(), new ElectricShaver() };
        
                // TODO: 충전 가능한 객체들을 충전하시오.
                for (Object obj : objs) {
                	if (obj instanceof Chargeable c) {
                		c.charge();
                	}
                }
                // END
            }
        }
        ```
        
- 모듈 간 독립적 프로그래밍 가능 → 개발 기간 단축
    - 예시
        
        ![image.png](image%201.png)
        
        ```java
        package com.ssafy.day05.b_interface.replace;
        
        public interface Calculator {
          int add(int a, int b);
        }
        
        class CalculatorStub implements Calculator {
          public int add(int a, int b) {
            System.out.printf("파라미터 확인: %d, %d%n", a, b);
            return 0;
          }
        }
        
        public class CalculatorImpl implements Calculator {
        
        	@Override
        	public int add(int a, int b) {
        		return a + b;
        	}
        }
        
        class CalculatorClient {
        	// Calculator calcLogic = new CalculatorStub();
          Calculator calcLogic = new CalculatorImpl();
        
          public void add() {
            System.out.println("첫 번째 정수를 입력하시오."); // 10
            Scanner scanner = new Scanner(System.in);
            int a = scanner.nextInt();
            System.out.println("두 번째 정수를 입력하시오."); // 20
            int b = scanner.nextInt();
            System.out.printf("결과: %d+%d=%d%n", a, b, calcLogic.add(a, b)); // 10+20=0 -> 10+20=30
            scanner.close();
          }
          
          public static void main(String[] args) {
        	CalculatorClient cc = new CalculatorClient();
        	cc.add();
          }
        }
        ```
        

# 4. default, static, private

## default method

인터페이스에 선언된 구현부가 있는 일반 메서드

- 메서드 선언부에 default modifier 추가 후 메서드 구현부 작성
    
    접근 제한자는 public으로 한정됨
    

### **필요성**

abstract 메서드는 모든 구현체들이 추가되는 메서드를 override 해야 함

→ default 메서드는 abstract가 아니므로 반드시 구현해야 할 필요는 없어짐

```java
package com.ssafy.day05.b_interface.staticdefault;

import java.util.Arrays;

interface Aircon {
    void makeCool();

    // TODO: 2. 건조기능을 추가해보자.
    default void dry() {
    	System.out.println("건조 기능이 필요합니다.");
    }
    // END

    // TODO: 3.Aircon이 동작 방식에 대해 설명해보자.

    // END

}

// 옛날 에어컨이라 dry 기능 없음
class OldisButGoodies1 implements Aircon {
    @Override
    public void makeCool() {
        System.out.println("전체 냉각해줘");
    }
}

class OldisButGoodies2 implements Aircon {
    @Override
    public void makeCool() {
        System.out.println("집중 냉각해줘");
    }
}

// TODO: 1. 무풍 에어컨을 구현해보자.
class NoWindAircon implements Aircon {

	@Override
	public void makeCool() {
		System.out.println("차가운 바람 없이 시원하게");
		dry();
	}
	
	@Override
	public void dry() {
		System.out.println("잘 말려 줘");
	}
}
// END

public class StaticDefaultMethod {
    public static void main(String[] args) {
        Aircon[] aircons = { new OldisButGoodies1(), new OldisButGoodies2(), new NoWindAircon() };
        for (Aircon aircon : aircons) {
            aircon.makeCool();
        }
    }
}

```

### **default method의 충돌**

method 우선 순위 =

- super class의 method 우선
    
    super class가 구체적 메서드를 갖는 경우 default method는 무시됨
    
- interface 간의 충돌
    
    하나의 인터페이스에서 default method를 제공하고, 다른 인터페이스에서도 같은 이름의 메서드(default 유무와 무관)가 있을 때 sub class는 반드시 override 해서 충돌 해결!
    

---

## static method

일반 static 메서드와 마찬가지로 별도의 객체가 필요 없음

구현체 클래스 없이 바로 인터페이스 이름으로 메서드에 접근해서 사용 가능

---

## private method

interface에 body를 가지는 메서드가 등장하면서 공통적으로 처리할 모듈 발생

- 외부로 공개할 필요가 없는 메서드 지정을 위해 private method 추가
- default 키워드를 사용하지 않으며 static 처리 가