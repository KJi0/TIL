# Java - 예외

# 1. 예외의 처리

## exception handling

### 에러와 예외

어떤 원인에 의해 어플리케이션이 오동작하거나 비정상적으로 종료되는 경우

**Error**: 메모리 부족,  Stack Overflow 등 → 디버깅으로 코드 개선

**Exception**: null 객체 사용, 읽으려는 파일 없음 → 예외 처리 코드

### exception handling(예외 처리)란?

예외 발생 시 어플리케이션의 비정상 종료를 막고 정상적인 실행 상태를 유지하는 것

**예외 감지** 및 **예외 발생 시 동작할 코드** 작성 필요

### 예외 클래스의 계층

![image.png](image.png)

- **checked exception**
    
    예외에 대한 대처 코드가 없으면 컴파일이 진행되지 않음
    
- **unchecked exception**
    
    대처 코드가 없더라도 컴파일은 진행됨
    
    ```java
    package com.ssafy.day09.a_basic;
    
    // 컴파일은 되므로 unchecked exception
    public class A_SimpleException {
        public static void main(String[] args) {
            int[] intArray = { 10 };
            System.out.println(intArray[2]);
            System.out.println("프로그램 종료합니다.");
        }
    }
    
    package com.ssafy.day09.a_basic;
    // try ~ catch 구문
    public class A_SimpleException {
        public static void main(String[] args) {
            int[] intArray = { 10 };
            try {
            	System.out.println(intArray[2]);
            } catch (ArrayIndexOutOfBoundsException e) {
            	System.out.println(e.getMessage());
            	e.printStackTrace();
            }
            System.out.println("프로그램 종료합니다.");
        } 
    }
    ```
    

### Exception 객체의 정보 활용

**Throwable의 주요 메서드**

- getMessage(): 발생된 예외에 대한 구체적 메시지 반환
- printStackTrace(): 예외가 발생된 메서드가 호출되기까지의 메서드 호출 스택을 출력 (디버깅 수단)

### try-catch 문에서의 흐름

1. try 블록에서 예외가 발생하면 JVM이 해당 excpetion 클래스의 객체 생성 후 던짐
- throw new XXException()
1. 던져진 exception을 처리할 수 있는 catch 블록에서 받은 후 처리
2. 정상적으로 처리되면 try-catch 블록을 벗어나 다음 문장 실행

**** try 블록에서 예외 발생하지 않은 경우** → catch 문 거치지 않고 다음 흐름 문장 실행

![image.png](image%201.png)

### Checked Exception 처리

처리하지 않으면 컴파일 불가

```java
package com.ssafy.day09.a_basic;

public class C_CheckedExceptionHandling {
    public static void main(String[] args) {
        // TODO: 다음에서 발생하는 예외를 처리해보자.
    	try {
              Class.forName("com.ssafy.day09.a_basic.C_CheckedExceptionHandling");
    	} catch (ClassNotFoundException e) {
    		e.printStackTrace();
    	}
        // END
        System.out.println("프로그램 정상 종료");
    }
}
```

```java
package com.ssafy.day09.a_basic;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.sql.DriverManager;
import java.sql.SQLException;

public class E_MultiExceptionHandling {
    @SuppressWarnings("resource")
    public static void main(String[] args) {
        // TODO: 다음에서 발생하는 예외를 처리해보자.
        try {
        	Class.forName("abc.Def"); // ClassNotFoundException
        	new FileInputStream("Hello.java"); // FileNotFoundException
            DriverManager.getConnection("Hello"); // SQLException
        } catch (ClassNotFoundException | FileNotFoundException e) {
        	System.out.println("무언가 리소스가 없어요~~" + e);
        } catch (SQLException e) {
        	System.out.println("DB 접속 실패" + e);
        }

        // END
        System.out.println("프로그램 정상 종료");
    }
}
```

```java
package com.ssafy.day09.a_basic;

import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.IOException;

public class F_HierachyException {
    @SuppressWarnings("resource")
    public static void main(String[] args) {
        String src = "./.project";
        // TODO: 상속 관계를 고려하여 다음에서 예외를 처리해보자.
        try {
        	FileInputStream input = new FileInputStream(src);
	        int readData = -1;
			while ((readData = input.read()) != -1) {
			System.out.print((char) readData);
			}
        } catch (FileNotFoundException e) {
        	e.printStackTrace();
        } catch (IOException e) {
        	e.printStackTrace();
        }
        // END

        System.out.println("파일 읽음 완료!");
    }
}
```

# 2. try ~ catch ~ finally

finally는 예외 발생 여부와 상관없이 언제나 실행

중간에 return을 만나는 경우도 finally 블록을 먼저 수행 후 리턴 실행

![시험 나온대요](image%202.png)

시험 나온대요

**주요 목적:** try 블록에서 사용한 리소스 반납

## try-with-resources

리소스의 자동 close 처리 (finally 역할)

```java
package com.ssafy.day09.b_trycatchfinally;

import java.io.FileInputStream;
import java.io.IOException;

public class C_TryWithResource {

    public static void main(String[] args) {
        C_TryWithResource test = new C_TryWithResource();
        test.useStream();
        test.useStreamNewStye();

    }

    public void useStream() {
        FileInputStream fileInput = null;
        try {
            fileInput = new FileInputStream("abc.txt");
            fileInput.read();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (fileInput != null) {
                try {
                    fileInput.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public void useStreamNewStye() {
        // TODO: useStream을 try~with~resource 문장으로 변경하세요.
    	try (FileInputStream fin = new FileInputStream("abc.txt")) {
    		fin.read();
    	} catch (IOException e) {
    		e.printStackTrace();
    	}
        // END
    }
}
```

### 주의점

- 일반 try 문장: try ~ catch / try ~ catch ~ finally / try ~ finally
    
    Try with resource 문장: try ~ catch
    
- close 시점 주의!!
    
    try~with~resources 문장은 nested try 블록을 구성
    
    ![image.png](image%203.png)
    

# 3. throws 활용

메서드에서 처리해야 할 하나 이상의 예외를 호출한 곳으로 전달

- 예외를 전달받은 메서드는 다시 예외 처리의 책임 발생

처리하려는 예외의 조상 타입으로 throws 처리 가능

## checked exception과 throws

반드시 try~catch 또는 throws 필요

## unchecked exception과 throws

throws 하지 않아도 전달되지만 결국은 try~catch 처리해야 함

## 로그 분석과 예외의 추적

Throwable의 printStackTrace는 메서드 호출 스택 정보 조회 가능

**꼭 확인해야 할 정보**

- 어떤 예외인가? → 예외 종류
- 예외 객체의 메시지는 무엇인가? → 예외 원인
- 어디서 발생했는가? → 디버깅 출발점
    - 참조하는 라이브러리는 과감히 건너뛰기

![image.png](image%204.png)

```java
package com.ssafy.day09.c_throws;

public class A_ThrowsTest {
    // TODO: 1. methodCall2()에서 uncheckedExceptionMethod()를 호출할 때 발생하는 예외를 throws로 처리하세요.
    // TODO: 2. methodCall2()에서 checkedExceptionMethod()를 호출할 때 발생하는 예외를 throws로 처리하세요.
     public static void main(String[] args){
        try {
        	methodCall1();
        } catch (ClassNotFoundException e) {
        	e.printStackTrace();
        } catch (ArithmeticException e) {
        	e.printStackTrace();
        }
        System.out.println("done");
    }

     private static void methodCall1() throws ClassNotFoundException {
        methodCall2();
    }

     private static void methodCall2() throws ClassNotFoundException {
        uncheckedExceptionMethod();
        checkedExceptionMethod();
    }

     private static void checkedExceptionMethod() throws ClassNotFoundException {
        // Class.forName("Hello"); 예외 원인 2
    	 Class.forName("com.ssafy.day09.c_throws.A_ThrowsTest");
    }

    private static void uncheckedExceptionMethod() {
        // int i = 1 / 0; // 예외 원인 1
    	int i = 1 / 1;
    }
}
```

## 메서드 재정의와 throws

메서드 재정의 시 조상 클래스 메서드가 던지는 예외보다 부모 예외를 던질 수 없

# 4. 사용자 정의 예외

# APPENDIX: 부적절한 예외 처리