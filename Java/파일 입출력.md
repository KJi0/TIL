# Java - 파일 입출력

# 1. 노드스트림

## I/O와 Stream

**I/O?** 데이터의 입력(input)과 출력(output)

데이터는 한쪽에서 주고 한쪽에서 받는 구조

이때 입력과 출력의 끝단: 노드(Node)

두 노드를 연결하고 데이터를 전송할 수 있는 개념: 스트림(Stream)

스트림은 단방향으로만 통신 가능하며 하나의 스트림으로 입출력을 같이 처리할 수 없음

노드의 종류: 키보드, 콘솔, 메모리, 파일…

입력 스트림: InputStream, Reader

출력 스트림: OutputStream, Writer

![image.png](image.png)

### Node Stream의 종류와 naming

Node Stream: node에 연결되는 스트림

byte → XXStream → Input or Output → 노드 타입에 따라 최종 노드 스트림

char → XXer → Input or Output → 노드 타입에 따라 최종 노드 스트림

![image.png](image%201.png)

## InputStream과 Reader

### 주요 메서드

**read():** 더 이상 읽을 데이터가 없는 경우 -1 리턴

**close():** 스트림을 종료해서 자원 반납

유니코드는 깨질 수 있음 → char는 Reader로 읽기

```java
package com.ssafy.day10.a_node;

import java.io.ByteArrayInputStream;
import java.io.CharArrayReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.Reader;
import java.io.StringReader;
import java.util.List;

public class SimpleInputTest {

    private String data1 = "hi java world";
    private String data2 = "자바는 객체지향 언어입니다.";

    private void read1() {
        try (InputStream input = new ByteArrayInputStream(data1.getBytes())) {
            int read = -1;
            while ((read = input.read()) != -1) {
                System.out.printf("읽은 값: %d, 문자로: %c%n", read, read);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void read2() {
        byte[] buffer = new byte[10];
        try (InputStream input = new ByteArrayInputStream(data2.getBytes())) {
            int read = -1;
            while ((read = input.read(buffer)) > 0) {

                System.out.printf("읽은 개수: %d, 문자열: %s%n", read, new String(buffer, 0, read));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
    
    /*
     * 읽은 개수: 10, 문자열: 자바는
     * 읽은 개수: 10, 문자열: 객체지�
     * 읽은 개수: 10, 문자열: �� 언어�
     * 읽은 개수: 9, 문자열: ��니다.
     */

    private void read3() {
        char[] buffer = new char[10];
        // TODO: CharArrayReader를 이용해 data2를 읽고 출력하시오.
        try (Reader reader = new CharArrayReader(data2.toCharArray())) {
        	int read = -1;
        	while( (read = reader.read(buffer) ) > 0) {
        		System.out.println(new String(buffer, 0, read));
        	}
        } catch (IOException e) {
        	e.printStackTrace();
        }
        // END
        
        // StringReader
        try (Reader reader = new StringReader(data2)) {
        	List<String> lines = reader.readAllLines();
        	lines.forEach(System.out::println);
        } catch (IOException e) {
        	e.printStackTrace();
        }
    }
    
    /*
     * 자바는 객체지향 언
     * 어입니다.
     * 자바는 객체지향 언어입니다.
     */

    public static void main(String[] args) {
        SimpleInputTest ns = new SimpleInputTest();
        // ns.read1();
        // ns.read2();
        ns.read3();
    }
}
```

## OutputStream과 Writer

### 주요 메서드

**write(c:** 문자열로 변환해서 출력ccccc

**close():** 스트림 종료해서 자원 반납. 내부적으로 flush()를 호출

**flush():** 버퍼가 있는 스트림에서 버퍼의 내용을 출력하고 버퍼를 비움

# 2. 노드스트림 활용

## File

가장 기본적인 입출력 장치 중 하나로 파일과 디렉터리를 다루는 클래스

mkdir(), createNewFile(), delete() 등 파일 또는 디렉을 생성, 삭제하지만 내용은 관여하지 못함

```java
package com.ssafy.day10.a_node;

import java.io.File;
import java.io.IOException;

public class UseFileTest {

    public static void main(String[] args) {
        try {
            // 절대 경로
            File temp = new File("c:\\Temp");
            System.out.printf("존재? %b, 디렉토리? %b%n", temp.exists(), temp.isDirectory());

            // 상대경로
            File current = new File(".");
            System.out.printf("여기는 어디? %s%n", current.getCanonicalPath(), current.getAbsolutePath());

            // 상대경로의 기준은 java program을 실행하는 위치(소스와 무관)
            // d:\>java -cp .;[project_root]\bin [package].UseFileStream

            // TODO: readme.txt에 해당하는 File 객체를 만들어 보자.
            //  프로젝트와 무관하게 파일을 찾을 때(절대 경로)
            File file1 = new File("C:\\SSAFY\\workspace\\01_java\\01_java\\src\\com\\ssafy\\day10\\a_node\\readme.txt");
            //  프로젝트 내부에서 파일을 찾을 때(상대 경로) 
            file1 = new File("./bin/com/ssafy/day10/a_node/readme.txt");
            //  특정 클래스 기준으로 파일을 찾을 때
            file1 = new File(UseFileTest.class.getResource("readme.txt").getFile());
            
            System.out.println(file1.canRead() + " : " + file1);
            // END
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

절대 경로, 상대 경로 차이:

```java
package com.ssafy.day10.a_node;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;

public class UseFileStream {
    public static void main(String[] args) throws IOException {
        UseFileStream st = new UseFileStream();

        System.out.printf("buffer size: %d, time: %d%n", 100, st.fileMove(100));
        // System.out.printf("buffer size: %d, time: %d%n", 1000, st.fileMove(1000));
        // System.out.printf("buffer size: %d, time: %d%n", 10000, st.fileMove(10000));
        // System.out.printf("buffer size: %d, time: %d%n", 100000, st.fileMove(100000));
        // System.out.printf("buffer size: %d, time: %d%n", 1000000, st.fileMove(1000000));
    }

    public long fileMove(int bufferSize) {
        long start = System.currentTimeMillis();
        // TODO: 본인의 컴퓨터에서 크기가 큰 파일을 선택하세요.
        File src = new File("C:\\SSAFY\\spring-tools-for-eclipse-5.0.1.RELEASE-e4.38.0-win32.win32.x86_64.zip");
        File target = new File("C:\\Temp\\sts.zip");
        // 데이터를 이동시킬 버퍼
        byte[] buffer = new byte[bufferSize];
        // TODO: bufferSize 크기의 byte []을 이용해서 src를 target에 복사하시오.
        try (
        	FileInputStream fin = new FileInputStream(src);
        	FileOutputStream fout = new FileOutputStream(target);
        	) {
        	int read = -1;
        	while( (read = fin.read(buffer)) > 0) {
        		fout.write(buffer, 0, read);
        	}
        	System.out.println("처리 완료");
        } catch (IOException e) {
        	e.printStackTrace();
        }
        // END
        return System.currentTimeMillis() - start;
    }
}

/*
 * 처리 완료
 * buffer size: 100, time: 18384
 */
```

```java
package com.ssafy.day10.a_node;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Date;
import java.util.Scanner;

public class NodeDiaryTest {
    final File target = new File("c:/Temp/diary.txt");

    public static void main(String[] args) throws IOException {
        NodeDiaryTest st = new NodeDiaryTest();
        st.writeDiary();
        st.readDiary();
    }

    private void writeDiary() {
        String readDiary = null;
        try (Scanner scanner = new Scanner(System.in); FileWriter writer = new FileWriter(target, true);) {
            System.out.println("일기를 작성합니다. 그만두려면 x를 입력하세요.");
            writer.write("\n오늘 날짜: - " + new Date() + "\n");
            // TODO: Scanner를 통해서 읽은 내용을 writer를 통해서 파일에 출력하시오.
            String str = null;
            while(true) {
            	str = scanner.nextLine();
            	if (str.equalsIgnoreCase("X")) {
            		break;
            	} else {
            		writer.write(str + "\n");
            	}
            }
            writer.flush();
            // END
            System.out.println("일기 저장 완료!!");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    private void readDiary() {
        System.out.println("읽기");
        char[] buffer = new char[10];
        try (FileReader reader = new FileReader(target)) {
            // TODO: reader를 이용해 diary의 내용을 읽은 후 콘솔에 출력하시오.
        	int read = -1;
        	while ((read = reader.read(buffer)) > 0) {
        		System.out.println(String.valueOf(buffer, 0, read));
        	}
            // END
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

/*
 * 일기를 작성합니다. 그만두려면 x를 입력하세요.
 * 집 가고 싶다
 * x
 * 일기 저장 완료!!
 * 읽기
 * 
 * 오늘 날짜: -
 * Tue Jan 2
 * 7 09:59:09
 * KST 2026
 * 집 가고 싶다
 */
```

# 3. 보조스트림

## 보조 스트림의 개념

보조 스트림: Filter Stream, Processing Stream

다른 스트림에 부가적인 기능을 제공하는 스트림

문자 set 변환, Buffering, 기본 데이터 형의 전송, 객체 입출력

스트림 체이닝: 필요에 따라 여러 보조 스트림을 연결해서 사용 가능

## 보조 스트림의 종류

- byte 스트림을 char 스트림으로 변환
    
    byte 기반 → InputStreamReader, OutputStreamWriter
    
- 버퍼링을 통한 속도 향상
    
    byte 기반 → BufferedInputStream
    
    char 기반 → BufferedReader
    
- 객체 전송
    
    byte 기반 → ObjectInputStream
    

### 생성

이전 스트림을 생성자의 파라미터에 연결

```java
new BufferedInputStream(System.in); // 키보드에 연결된 node stream
new ObjectInputStream(new BufferedInputStream(new FileInpustStream());
```

### 종료

보조 스트림의 close()를 호출하면 노드 스트림의 close()까지 호출됨

### 사용할 스트림의 결정 과정

노드가 무엇인가 → 타입은 문자열인가? 바이트인가? → 방향이 무엇인가? : 노드 스트림 구성

→ 추가 기능이 필요한가? : 보조 스트림 구성

**키보드에서 유니코드 문자를 안전하고 빠르게 읽고 싶다면?**

keyboard → byte → 읽기 → InputStream(System.in) → InputStreamReader → BufferedReader

# 4. 보조스트림 활용

## **InputStreamReader & OutputStreamWriter**

byte 기반 스트림을 char 기반으로 변경해 주는 스트림

## **Buffered 계열**

### 버퍼의 역할

![image.png](image%202.png)

스트림의 입출력 효율을 높이기 위함

```java
package com.ssafy.day10.b_processing.buffered;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

public class ProcessingFileCopyTest {
    public static void main(String[] args) {
        File src = new File("c:/Windows/explorer.exe");
        File target = new File("c:/Temp/copied_explorer.exe");

        try (FileInputStream fi = new FileInputStream(src); FileOutputStream fo = new FileOutputStream(target);) {
            copy("노드", fi, fo);
        } catch (IOException e) {
            e.printStackTrace();
        }

        try (BufferedInputStream bi = new BufferedInputStream(new FileInputStream(src));
                BufferedOutputStream bo = new BufferedOutputStream(new FileOutputStream(target));) {
            copy("보조", bi, bo);
        } catch (IOException e) {
            e.printStackTrace();
        }

    }

    public static void copy(String type, InputStream input, OutputStream output) throws IOException {
        long start = System.nanoTime();
        byte[] cart = new byte[1024];
        int read = -1;
        while ((read = input.read(cart)) > 0) {
            output.write(cart, 0, read);
        }
        long end = System.nanoTime();
        System.out.printf("타입: %s, 소요 시간: %10dns%n", type, end - start);
    }
}

/*
 * 타입: 노드, 소요 시간:   14038100ns
 * 타입: 보조, 소요 시간:    4566100ns
 */
```

### BufferedReader & BufferedWriter

readLine() → 줄 단위로 데이터를 읽어들임

```java
package com.ssafy.day10.b_processing.buffered;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;

public class ProcessingTextReadTest {
    public static void main(String[] args) {
        File src = new File("./.project");
        try (BufferedReader br = new BufferedReader(new FileReader(src));) {
            String line = null;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 객체 직렬화(serialization)

객체를 파일 등에 저장하거나 네트워크로 전송하기 위해 연속적 데이터로 변환하는 것

반대의 경우는 역 직렬화(deserialization)

### 직렬화 되기 위한 조건

- Serializable 인터페이스를 구현할 것
- 클래스의 모든 멤버가 Serializable 인터페이스를 구현해야 함
- 직렬화에서 제외하려는 멤버는 transient 선언

### SerialVersionUID

클래스의 변경 여부를 파악하기 위한 유일 키

직렬화 할 때의 UID와 역 직렬화 할 때의 UID가 다를 경우 예외 발생

직렬화되는 객체에 UID가 설정되지 않았을 경우 컴파일러가 자동 생성

- 멤버 변경으로 인한 컴파일 시마다 변경 → InvalidClassException 초래

직렬화되는 객체에 대해 serialVersionUID 설정 권장

## ObjectInputStream & ObjectOutputStream

```java
package com.ssafy.day10.b_processing.object;

import java.io.Serializable;

// TODO: Person 을 직렬화 가능하도록 처리하시오.
public class Person implements Serializable {
	
    private static final long serialVersionUID = 3906141983886065501L;
		public static int age = 10;
    private String id;
    private transient String pass; // 민감한 데이터
    private Address addr; // has a 관계의 다른 객체

    public Person(String id, String pass, String zipCode, String city) {
        this.id = id;
        this.pass = pass;
        this.addr = new Address(zipCode, city);
    }

    @Override
    public String toString() {
        return "[id=" + id + ", pass=" + pass + ", addr=" + addr + "]" + age;
    }

     class Address implements Serializable {
        private String zipCode;
        private String city;

        public Address(String zipCode, String city) {
            this.zipCode = zipCode;
            this.city = city;
        }

        public String toString() {
            return "Address [zipCode=" + zipCode + ", city=" + city + "]";
        }
    }
}

package com.ssafy.day10.b_processing.object;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;

import com.ssafy.day04.c_polymorphism.InstanceOfTest;

public class ObjectStreamTest {
    public static void main(String[] args) {
        write();
        read();
    }

    private static File target = new File("c:/Temp/objPerson.dat");

    private static void write() {
        Person person = new Person("홍길동2", "pass1234", "123-456", "seoul");
        // TODO: person을 target에 저장하시오.
        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(target))) {
        	oos.writeObject(person);
        	System.out.println("저장 끝");
        } catch (IOException e) {
        	e.printStackTrace();
        }
        // END
    }

    private static void read() {
        // TODO: target에서 person을 읽어서 내용을 출력하시오.
    	try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(target))) {
    		Object readed = ois.readObject();
    		if (readed != null && readed instanceof Person p) {
    			System.out.println("읽어들인 객체: " + p);
    		}
    	} catch (IOException | ClassNotFoundException e) {
    		e.printStackTrace();
    	}
        // END
    }
}

/*
 * 저장 끝
 * 읽어들인 객체: [id=홍길동2, pass=null, addr=Address [zipCode=123-456, city=seoul]]10
 */
```

## Scanner와 BufferedReader

char 형태의 데이터를 읽기 위한 클래스들

- **Scanner:** 자동 형변환을 지원하는 등 사용이 간편하지만 느림
- **BufferedReader:** 직접 스트림을 구성해야 하는 등 번거롭지만 빠름

```java
package com.ssafy.day10.b_processing.buffered;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Scanner;

public class BufferedReaderVsScanner {
    private File file = null;

    public static void main(String[] args) throws IOException {
        BufferedReaderVsScanner rs = new BufferedReaderVsScanner();
        rs.makeFile();
        rs.useScanner();
        rs.useBufferedReader();
    }

    @SuppressWarnings("unused")
    private void useScanner() throws FileNotFoundException {

        try (Scanner s = new Scanner(file)) {
            long start = System.nanoTime();
            String line = null;
            while (s.hasNextLine()) {
                line = s.nextLine();
                // System.out.println(line);
            }
            System.out.printf("sc: %10d%n", System.nanoTime() - start);
        }
    }

    @SuppressWarnings("unused")
    private void useBufferedReader() throws IOException {

        try (BufferedReader br = new BufferedReader(new FileReader(file))) {
            long start = System.nanoTime();
            String line = null;
            while ((line = br.readLine()) != null) {
                // System.out.println(line);
            }
            System.out.printf("br: %10d%n", System.nanoTime() - start);
        }
    }

    private void makeFile() {
        file = new File("./sample.txt");
        try (BufferedWriter output = new BufferedWriter(new FileWriter(file))) {
            for (int i = 0; i < 1_000_000; i++) {
                output.write("" + i);
                output.newLine();
            }
            System.out.println("파일 작성 완료");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}

/*
 * 파일 작성 완료
 * sc:  167647800
 * br:   26657500
 */
```