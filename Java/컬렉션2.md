# Java - 컬렉션2

# 1. 람다 표현식

## 타입과 메서드의 추정

1. Arrays.sort(strs, [Compaator 필요]);
2. (o1, o2) → o1.compareTo(o2)*-1 T 타입 변수 2개를 받아서 int를 반환하는 메서드가 하나 있군!
3. Comparator 타입으로 인정!

```java
package com.ssafy.day08.a_lambda;

import java.util.Arrays;
import java.util.Comparator;

public class B_Sorting {
    private String[] langs = { "Java", "C", "JavaScript", "Python" };

    public void sortByAnnonymous() {
       Comparator<String> c;
        Arrays.sort(langs,
                new Comparator<String>() {
                    @Override
                    public int compare(String o1, String o2) {
                        return o1.compareTo(o2) * -1;
                    }
                });

        System.out.println("문자열 내림차순: " + Arrays.toString(langs));
    }

    public void sortByLambda() {
        // TODO: lambda 식을 이용하여 langs를 문자열의 길이 순으로 오름차순 정렬하시오.
    	Arrays.sort(langs, (s1, s2) -> {
    		int len1 = s1.length();
    		int len2 = s2.length();
    		return Integer.compare(len1, len2);
    	});
        // END
        System.out.println("길이 오름차순: " + Arrays.toString(langs));
    }

    public static void main(String[] args) {
        B_Sorting st = new B_Sorting();

        st.sortByAnnonymous();
        st.sortByLambda();
    }
}

```

## 메서드 참조와 생성자 참조

### 메서드 참조

람다 실행문 내부에서 다른 함수 하나만을 실행하는 경우 :: 연산자를 이용해 기존 메서드 참조

- <소유자>::<파라미터를 사용하는 소유자의 메서드>

```java
package com.ssafy.day08.a_lambda;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.function.Function;
import java.util.function.Supplier;

public class C_MethodAndConstructorRef {

    public static void main(String[] args) {
        methodRef1();
        //methodRef2();
        //constructorRef();
    }

    private static void methodRef1() {
        // 다음 배열을 다양한 방식(lambda, 메서드 참조)으로 정렬해보자.
        Integer[] nums = { 1, 5, 4, 3, 8, 9 };
        // TODO: 위 배열을 숫자 오름차순으로 정렬하시오.
        Arrays.sort(nums, (i1, i2) -> Integer.compare(i1, i2));
        Arrays.sort(nums, Integer::compare);
        // END
    }

    private static void methodRef2() {
        List<String> source = List.of("Hello", "Java", "World");
        List<String> target = new ArrayList<>();
        // TODO: source의 내용을 target으로 옮겨보자.

        // END

        // TODO: forEach를 이용하여 source의 내용을 출력하세요.
        source.forEach(str -> System.out.println(str));
        source.forEach(System.out::println);
        // END
    }

    private static <T> void constructorRef() {
        Supplier<StringBuilder> s1 = () -> new StringBuilder();
        Supplier<StringBuilder> s2 = StringBuilder::new;
        StringBuilder sb1 = s2.get();

        Function<String, StringBuilder> f1 = (init) -> new StringBuilder(init);
        Function<String, StringBuilder> f2 = StringBuilder::new;
        StringBuilder sb2 = f2.apply("hong");

        System.out.println(sb2);

        // TODO: ArrayList 객체를 다양한 생성자 참조로 만들어보자.

        // END

    }
}
```

# 2. 표준함수형 인터페이스

## 함수형 프로그래밍

일반적으로 객체지향의 java 프로그래밍은 클래스와 메서드 이름, 구조가 중요

일반적인 함수형 프로그래밍 언어에서 함수 형태는 구조적이며 이름이 불필요

→ 험수의 형태는 함수형 인터페이스로, 구현은 람다식으로 작성

## 표준함수형 인터페이스

### 표준 API 종류

자주 사용되는 함수 구조를 표준 인터페이스로 java.util.function package에 정의

주로 메서드 또는 생성자의 파라미터로 람다식을 제공하기 위함

```java
package com.ssafy.day08.a_lambda;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Random;

public class E_FunctionalApiTest {
    private List<Integer> list = List.of(1, 2, 3, 4, 5, 6, 7, 8, 9);
    private Map<String, Integer> map = new HashMap<>(Map.of("hong", 100, "jang", 80, "lim", 95, "kim", 4));

    public static void main(String[] args) {
        E_FunctionalApiTest fpt = new E_FunctionalApiTest();
        // fpt.consumerTest("hong");
        fpt.supplierTest("hong");
        // fpt.functionTest();
        // fpt.operationTest();
        // fpt.predicateTest();
    }

    public void consumerTest(String name) {
        // TODO: list와 map의 각 요소를 출력해보자. list는 단순 출력, map은 이름:점수 형태
    	list.forEach(str -> System.out.println(str));
    	list.forEach(System.out::println);

    	map.forEach(k, v) -> System.out.println(k + " :"_])
    	// END

        Optional<Integer> optional = Optional.ofNullable(map.get(name));
        // TODO:map에서 name의 점수를 조회해서 값이 있을 80이상이면 우수, 미만이면 노력필요, 값 없으면 대상없음이라고
    	optional.ifPresentOrElse(score -> {
    		if (score >= 80) {
    			System.out.println("우수");		
    		} else {
    			System.out.println("노력 필요");
    		}
    	}, () -> {
    		System.out.println("대상 없음");
    	});
        // END
    }

    public void supplierTest(String name) {
        Optional<Integer> optional = Optional.ofNullable(map.get(name));
        // TODO: map에서 name의 성적을 조회하고 만약 score가 null이면 0~100 사이의 값을 설정해보자. (orElseGet)
        Integer result = optional.orElseGet(() -> new Random().nextInt(100));
        // END
    }

    public void functionTest() {
        String name = "hong";
        // TODO: map에 name이 없었다면 score를 1로 추가하고 있었다면 +1 해주세요.(merge)
        Integer result0 = map.merge(name, 1, (ov, nv) -> ov + nv);
        // END

        // TODO: map에 jang이 있다면 기존 점수에 100점을 더해서 값을 출력해주세요.(computeIfPresent)
        Integer result = map.computeIfPresent("jang", (k, v) -> v + 100);
        // END
        System.out.println(map);
    }

    public void operationTest() {
        // TODO: list의 요소를 2배씩으로 대체 하세요. (replaceAll)
    	list.replaceAll(i -> i * 2);
        // END
        System.out.println(list);
    }

    public void predicateTest() {
        // TODO: map의 Entry 중 name이 3자 넘고 score가 90점 이상인 것들을 삭제 후 출력해보자.(removeIf)
    	map.entrySet().removeIf(entry -> entry.getKey().length() > 3 && entry.getValue() >= 90);
        // END
        System.out.println(map);
    }
}
```

# 3. Stream API

## Stream이란?

java.util.stream package

배열 및 Collection의 요소를 하나씩 참조해서 처리하는 목적

람다와 내부 반복자를 이용해 컬렉션 다루는 코드를 간결화

### Stream API의 역할 및 특징

컬렉션, 배열 등 데이터 소스에 대한 공통된 접근 방식 제공

손쉬운 병렬 처리

```java
set        .stream().forEach(System.out::println); // 순차 처리
set parallelStream().forEach(System.out::println); // 병렬 처리
```

주어진 목록에서 글자수가 3자가 넘는 요소들의 글자수 평균은?

```java
public void streamStyle() {
	double avg = heroes.stream()
										 .mapToInt(String::length) // 글자 수로 변환
										 .filter(len -> len > 3) // 필터링
										 .average() // 평균
										 .getAsDouble(); // 결

	System.out.println(avg);
}
```

## Stream 자료 처리

### 맵/리듀스 모델 지원

맵: 데이터를 작은 단위(chunk)로 나누어(splitting) 지정된 함수를 적용(mapping) 처리

리듀스: 결과를 모아서 최종 결과를 생성

→ 대량의 컬렉션 처리를 위한 방식

중간 처리들과 최종 처리를 조합해서 사용

중간 처리:

최종 처리:

### Stream의 종류와 획득

```java
package com.ssafy.day08.b_stream.make;

import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class FromCollectionTest {

    public static void main(String[] args) {
        String[] heroes = { "아이언맨", "스파이더맨", "헐크", "토르" , "홍길동", "이몽룡", "성춘향"};
        Stream<String> fromArray = Arrays.stream(heroes);

        List<String> heroList = fromArray.collect(Collectors.toList());

        // TODO: heroList를 통해 stream / parallel stream을 만들고 사용해보자.
        heroList.stream().forEach(str -> System.out.println(Thread.currentThread().getName() + " : " + str));
        System.out.println("----------------");
        heroList.parallelStream().forEach(str -> System.out.println(Thread.currentThread().getName() + " : " + str));
        // END
    }
}

```

### 단계별 주요 처리 메서드

중간 처리는 최종 처리가 진행될 때까지 지연됨

```java
package com.ssafy.day08.b_stream.middle;

import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

public class StreamMiddleTest {
    List<String> words;

    public static void main(String[] args) {
        StreamMiddleTest ft = new StreamMiddleTest();
        ft.words = setUpStream();
        ft.filterTest();
        //ft.sortTest();
        //ft.mapTest();
        //ft.flatMapTest();
    }

    public static List<String> setUpStream() {
        List<String> words = null;
        try {
            Path text = Paths.get(StreamMiddleTest.class.getResource("../song.txt").toURI());
            words = Files.readAllLines(text).stream().flatMap(data -> Arrays.stream(data.split("[,-. ]")))
                    .collect(Collectors.toList());

            System.out.println("초기 단어 개수: " + words.size());
        } catch (Exception e) {
            e.printStackTrace();
        }
        return words;
    }

    private void filterTest() {
        System.out.println("중복 제거 결과: " + words.stream().distinct().count());
        System.out.println("처음 다섯개 단어: ");
        words.stream().limit(5).forEach(System.out::println);

        // TODO: 다음의 요청 사항을 stream으로 구현해보자.
        //  1. words에서 단어의 길이가 5 이상인 단어의 개수는?
        long cnt = words.stream().filter(word -> word.length() >= 5).count();
        System.out.println("words에서 단어의 길이가 5 이상인 단어의 개수는 " + cnt);
        //  2. 오가 들어가는 단어 중 처음 4개를 생략하고 2개 출력해보자.
        words.stream().filter(word -> word.contains("오")).skip(4).limit(2).forEach(System.out::println);
        //  3. 0~100 까지의 정수에서 짝수의 합을 구해보자.
        int sum = IntStream.rangeClosed(0, 100).filter(n -> n % 2 == 0).sum();
        System.out.println(sum);
        // END

    }

    private void sortTest() {
        words.stream().distinct().sorted((a, b) -> {
            return a.compareTo(b) * -1;
        }).limit(3).forEach(System.out::println);

        // TODO: 다음의 요청 사항을 stream으로 구현해보자.
        //  words에서 중복을 제거하고 글자수에 대한 내림차순 정렬 했을 때 가장 긴 문자열의 길이는?
        words.stream().distinct()
        			  .sorted((s1, s2) -> Integer.compare(s1.length(), s2.length()) * -1)
        			  .findFirst()
        			  .ifPresent(System.out::println);
        // END
    }

    private void mapTest() {
        List<String> list = Arrays.asList("Hello", "Stream");
        list.stream().map(item -> item.toCharArray()).forEach(arr -> System.out.println(arr.length));

        // Integer -> String
        IntStream is = IntStream.range(0, 5);
        is.mapToObj(num -> "제곱: " + num * num).forEach(System.out::println);

        Map<String, Integer> map = Map.of("hong", 100, "jang", 80, "lim", 95, "kim", 4);
        // TODO: map의 점수에 이름의 길이를 곱한 총 합을 출력해보자.
        map.entrySet().stream().mapToInt(e -> e.getKey().length() * e.getValue()).sum(); // map은 collection이 아니라서 stream이 없음. entrySet으로 접근해야 함
        // END
    }

    private void flatMapTest() {
        List<String> list = Arrays.asList("Hello", "Stream");
        list.stream().map(item -> item.toCharArray()).forEach(arr -> System.out.println(arr.length));
        list.stream().flatMap(item -> Arrays.stream(item.split(""))).forEach(System.out::println);

        // TODO: 1단의 합~9단의 합을 모두 더해서 반환해보자.

        // END
    }
}
```

```java
package com.ssafy.day08.b_stream.terminate;

import java.io.IOException;
import java.net.URISyntaxException;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.OptionalInt;
import java.util.Random;
import java.util.stream.IntStream;
import java.util.stream.Stream;

import com.ssafy.day08.b_stream.middle.StreamMiddleTest;

public class TerminateTest {
    private List<String> words = StreamMiddleTest.setUpStream();
    private Map<String, Integer> map = Map.of("hong", 100, "jang", 80, "lim", 95, "kim", 70);

    public static void main(String[] args) throws IOException, URISyntaxException {
        TerminateTest tt = new TerminateTest();
        tt.matchingTest();
        //tt.aggregateTest();
        tt.reduceTest();
        //tt.findTest();
    }

    private void matchingTest() {
        boolean anyMatch = words.stream()
                .distinct()
                .anyMatch(word -> word.length() >= 5);

        System.out.println("stream의 단어들에는 5글자 이상인 것이 있다? " + anyMatch);

        // TODO: 모든 학생의 점수가 80점 이상인지 확인해보자.

        // END

    }

    public void aggregateTest() {

        IntStream is = new Random().ints(10, 1, 100);
        System.out.println("총합은: " + is.sum());

        words.stream().max(String::compareTo).ifPresent(val -> {
            System.out.println("최대값은: " + val);
        });

        IntStream is2 = new Random().ints(10, 1, 100);
        // TODO: is2에서 짝수 중 최소값을 찾아서 반환하세요. 없다면 -1을 반환한다.

        // END
    }

    public void reduceTest() {
        IntStream is = Arrays.stream(new int[] { 1, 2, 3, 4, 5 });
        int sumByReduce = is.reduce(0, (sum, num) -> sum + num);
        System.out.println(sumByReduce);

        // TODO: 학생들의 시험점수가 짝수이면 그대로, 홀수이면+1점으로 처리해서 총점을 구해보자.
        Map<String, Integer> map = Map.of("hong", 100, "jang", 80, "lim", 95, "kim", 70);
        Integer result = map.values().stream().reduce(0, (p, n) -> p + (n % 2 == 0 ? n : (n + 1)));
        System.out.println(result);
        // END

        class Info {
            int sum, cnt, max = Integer.MIN_VALUE;
            double avg;
            String highest;

            public Info() {
            }

            public Info(int sum, int cnt, int max, double avg, String highest) {
                this.sum = sum;
                this.cnt = cnt;
                this.max = max;
                this.highest = highest;
                this.avg = avg;
            }

            @Override
            public String toString() {
                return "Info [sum=" + sum + ", cnt=" + cnt + ", max=" + max + ", avg=" + avg + ", highest=" + highest + "]";
            }

        }

        // TODO: Info를 이용하여 총점, 평균, 최고득점자, 최고점을 반환해보자.

        // END
    }

    private void findTest() {
        String[] strs = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789".split("");
        Stream<String> stream = Arrays.stream(strs);
        Optional<String> sequentialFirst = stream.findAny();
        System.out.println(sequentialFirst.orElse("none"));

        Optional<String> parallelFirst = Arrays.stream(strs).parallel().findAny();
        System.out.println(parallelFirst.orElse("none"));

    }
}

```

```java
package com.ssafy.day08.b_stream.terminate;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.function.BiConsumer;
import java.util.function.BiFunction;
import java.util.function.BinaryOperator;
import java.util.function.Supplier;
import java.util.stream.Collectors;

import com.ssafy.day08.b_stream.middle.StreamMiddleTest;

public class CollectTest {
    private List<String> words = StreamMiddleTest.setUpStream();

    public static void main(String[] args) {

        CollectTest ct = new CollectTest();
        ct.collectToList();;
        //ct.collectToMap();
    }

    private void collectToList() {
        // supplier: 최종 반환할 collection
        Supplier<List<String>> s = ArrayList::new;
        // accumulator: 하나씩 돌면서 누적시킴
        BiConsumer<List<String>, String> a = (list, str) -> list.add(str);
        // combiner: 두개의 List를 병합(parallel)
        BiConsumer<List<String>, List<String>> c = (l1, l2) -> l1.addAll(l2);

        words.parallelStream().filter(str -> str.length() >= 5).distinct().sorted().limit(5).collect(s, a, c).forEach(System.out::println);
        System.out.println();
        words.stream().filter(str -> str.length() >= 5).distinct().sorted().limit(5).collect(s, a, (l1, l2) -> {}).forEach(System.out::println);
        System.out.println();

        // TODO: 위 내용을 static 함수를 활용한 형태로 변경해보자.
        List<String> list = words.stream().filter(str -> str.length() > 5).collect(Collectors.toList());
        // END
    }

    /**
     * 단어별 등장 회수를 map에 담아 반환하세요. 단 등장 회수로 내림차순 정렬하고 상위 5개만 반환한다.
     */
    private void collectToMap() {
        // supplier: 최종 반환할 collection
        Supplier<Map<String, Integer>> supplier = HashMap::new;
        // accumulator: 하나씩 돌면서 누적 시킴
        BiConsumer<Map<String, Integer>, String> accumulator = (map, str) -> map.merge(str, 1, ((ov, nv) -> ov+nv));
        // combiner: 두개의 Hashmap을 병합함
        BiConsumer<Map<String, Integer>, Map<String, Integer>> combiner = (m1, m2) -> m2.forEach((k, v) -> m1.merge(k, v, Integer::sum));

        Map<String, Integer> result = words.parallelStream().collect(supplier, accumulator, combiner);

        result.entrySet().stream().sorted((i, j) -> Integer.compare(i.getValue(), j.getValue()) * -1).limit(5).forEach(System.out::println);
        System.out.println();

        // TODO: 위 내용을 static 함수를 활용한 형태로 변경해보자.

        // END
    }
}

```