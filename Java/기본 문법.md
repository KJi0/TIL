# Java - 기본 문법

### 1. 자바 기본

- **변수 (Variable)**
    
    자료를 저장하기 위한 메모리 공간
    
    데이터 형태(Type)에 따라 메모리 공간의 크기가 달라짐
    
    - **기본형**
        
        미리 정해진 크기
        
        변수에 값 **자체**를 저장
        
        ![image.png](image.png)
        
        자바에서 맨앞 비트는 Sign bit → 뒤에 7칸만 데이터로 사용 ⇒ 7승부터 시작
        
        **기본 타입**은 정수형: int, 실수형: double
        
        실수형은 정밀도(F) 차이
        
        char은 부호 비트 사용 안 해서 전체 비트를 다 데이터로 사용
        
    - **참조형**
        
        크기가 미리 정해질 수 없음
        
        실제 값을 참조하는 **주소**만 저장
        
        포인터랑 비슷한 개념
        
        String은 기본형 아닌 참조형
        
        ```java
        String str1 = “Hello” // literal 할당
        String str2 = new String(”Hello”); // 생성자 이용
        ```
        
        → 두 방식의 차이는?
        
        ![image.png](image%201.png)
        
        new는 매번 새로운 객체를 생성하므로 메모리 아끼려면 문자열 풀 사용
        
        Q. 두 문자열은 같습니까?
        
        → 잘못된 질문. 같은 객체(==) or 같은 내용(equals)
        
        ```java
        package com.ssafy.day01.a_basic;
        
        import java.util.ArrayList;
        
        public class Basic_01 {
        
            public static void main(String[] args) {
                int i = 10;
                double d = 3.14;
                System.out.printf("i = %d, d = %f\n", i, d);
                // TODO: 01. 다음의 데이터를 저장하기 위한 변수들을 선언하고 값을 할당해보자.
                //  식사여부, 반번호, 신발사이즈, 갤럭시트라이폴드가격(360만원), 별간거리, 몸무게, 환율, 메달
                boolean eat = true;
                int classNo = 7;
                short shoeSize = 270;
                int price = 360000;
                long distance = 1111111111111L;
                float weight = 80.5f;
                double rate = 1480.44444444;
                // END
            }
        }
        ```
        
- **포맷 문자 형식**
    
    flag나 percision 잘 기억해 두기
    

![image.png](image%202.png)

- **정수의 문제점**
    
    **Integer**는 int에 대한 wrapper class
    
    정수 계산 시 **overflow** 주의
    

- **실수의 문제점**
    
    2진수로 저장 시 값 손실 발생 → 정밀도 문제
    
    유효 자리수를 이용한 반올림 처리
    
    ⇒ BigDecimal 사용
    
- **형 변환**
    
    char ↔ int
    
    - **명시적 형 변환**
        
        ```java
        double d = 100.5; // result = 100
        int result = (int)d; // d = 100.5
        ```
        
    - **묵시적 형 변환**
        
        ```java
        byte b = 10;
        int i = (int)b;
        int i2 = b;
        ```
        
    - **묵시 vs 명시**
        
        ![image.png](image%203.png)
        
        묵시적 형변환은 자료 손실 걱정 없으므로 연산 생략
        
        명시적 형변환은 값 손실 발생 가능하므로 프로그래머 책임하에 진행
        
        값의 크기, 타입의 크기가 아닌 **타입의 표현 범위**가 커지는 방향으로 할당할 경우 **묵시적 형변환** 발생
        
        ![image.png](image%204.png)
        

- **wrapper class**
    
    8개의 기본형에 대응하는 8개의 클래스
    
    객체형은 기본형과 달리 추가적인 속성과 기능 포함
    
    - Integer.MAX_VALUE
    - Integer.compare(int a, int b)
    
    형변환 관련 메서드
    
    - Integer.parseInt(String str)
    - Integer.valueOf(int i)
    - Integer.intValue()
    
    → wrapper class가 제공
    
    ![image.png](image%205.png)
    
- **산술연산 주의사항**
    
    산술 이항 연산자는 연산 전에 피연산자의 타입을 일치시킴
    
    피연산자의 크기가 int 미만이면 int로 변경한 후 연산 진행
    
    두 개의 피연산자 중 큰 타입으로 형 변환 후 연산 진행
    

- **조건문**
    
    ![image.png](image%206.png)
    
    long은 안 됨
    
    - **Switch expressions**
        
        표현식 자체가 값을 반환 가능, 자동 break
        
        block 구성해야 하는 경우 yield 키워드 사용 (yield는 block에서만 사용)
        
        여러 조건을 쉼표로 구분해서 한 라인에 처리 가능
        
        ![image.png](image%207.png)
        

### 2. 배열

**동일한 타입의 데이터 0개 이상**을 하나의 **연속된 메모리 공간에서 관리**하는 것

- **생성**
    
    new int[3]: int 타입의 자료 3개를 저장할 수 있는 배열을 메모리에 생성
    
    points = new int[3]: 메모리에 있는 배열을 가리키는 reference 타입 변수
    
    생성과 동시에 초기화
    
    int[] b = new int[]{1,3,5,6,8};
    
    int[] c = {1,3,5,6,8};
    
    선언과 생성을 따로 처리할 경우 초기화 주의
    
    int[] points;
    
    points = {1,3,5,6,8}; // 컴파일 오류
    
    int[] points;
    
    points = new int[]{1,3,5,6,8}; // 선할 때는 배열의 크기를 알 수 없을 때
    

- **사용**

![image.png](image%208.png)

2번째 요소에는 0이 들어감

- 배열의 크기는 불변
    
    배열은 최초 메모리 할당 이후 변경 불가
    
    개별 요소는 다른 값으로 변경 가능하나, 요소를 추가하거나 삭제할 수는 없음
    
    ![image.png](image%209.png)
    
    기존 배열은 가비지 컬렉션으로 정리
    

### 3. 다차원 배열

- 생성
    
    선언, 생성, 할당 동시에
    
    int[][] arr = { {0,1,2}, {0,1,2}, {0,1,2}, {0,1,2} };
    

- 2차원 배열의 메모리 사용 단계

![image.png](image%2010.png)

![image.png](image%2011.png)

![image.png](image%2012.png)

- Array 순회/탐색
    
    특정 좌표로부터 주변을 탐색하는 경우, 배열의 범위를 벗어나지 않기 위한 코드 필요