# 알고리즘 - 연결리스트1

## 1. 리스트

순서 있는 데이터의 집합, 중복 가능

1. 순차 리스트: 배열 기반
2. 연결 리스트: 메모리 동적 할당 기반

### 순차 리스트의 문제점

- 삽입/삭제 연산에서 원소들을 **이동**시키는 작업이 필요
    
    → 원소 개수가 많고 삽입/삭제 연산이 늘어날수록 소요 시간이 크게 증가
    
- 배열의 크기가 정해져 있는 경우, 실제 사용 메모리보다 크게 할당해 메모리의 낭비를 초래할 수도 있음

### 연결 리스트(Linked List)

개별적으로 위치하고 있는 각 원소를 연결해 하나의 자료구조를 이룸

**링크를 통해 원소에 접근**하므로, 물리적 순서를 맞추기 위한 작업 필요 X

자료구조 크기를 동적으로 조정할 수 있어 메모리 효율 높음

![image.png](image.png)

**Head**: 연결 리스트의 첫 노드에 대한 참조값을 가짐

### 연결 리스트의 종류

- **단순 연결 리스트:** 노드 연결 한방향 관리 → 링크 1개 ⇒ 이전 노드 정보 모름
- **이중 연결 리스트:** 노드 연결 양방향 관리 → 링크 2개 ⇒ 관리가 힘듦
- **원형 연결 리스트**

---

## 2. 단순 연결 리스트

헤드는 시작 노드, 링크 필드가 연속적으로 다음 노드를 가리킴

**링크 필드가 Null**인 노드가 연결 리스트의 가장 **마지막 노드**

![image.png](image%201.png)

---

## 3. 단순 연결 리스트: 삽입 연산

1. 새로운 노드 생성
2. 데이터 채우기
3. head의 참조값 연결
4. 새로운 노드의 참조값을 head에 연결

---

## 4. 단순 연결 리스트: 삭제 연산

1. 삭제할 노드의 앞 노드 (선행노드) 탐색
2. 삭제할 노드의 링크를 선행노드의 링크에 복사
3. 삭제할 노드의 링크에 NULL 저장

---

## 5. 단순 연결 리스트 응용: 스택 구현

```java
public interface IStack<E> {

	void push(E data);
	E pop();
	E peek();
	boolean isEmpty();
	int size();
}
```

```java
public class Node<T> {
	
	public T data;
	public Node<T> link;
	
	public Node(T data) {
		this.data = data;
	}
	
	public Node(T data, Node<T> link) {
		super();
		this.data = data;
		this.link = link;
	}
	
	@Override
	public String toString() {
		return "Node [data=" + data + ", link=" + link + "]";
	}
}
```

```java
import java.util.EmptyStackException;

public class SsafyStack<E> implements IStack<E> {
	
	private Node<E> top; // head
	
	@Override
	public void push(E data) {
		// 새 노드 생성 후 (헤드노드의 값을 새 노드의 링크 필드로...) 헤더노드의 값으로
		top = new Node<E>(data, top);
	}
	
	@Override
	public E pop() {
		if (isEmpty()) throw new EmptyStackException();
		
		Node<E> popNode = top;
		top = popNode.link;
		popNode.link = null;
		return popNode.data;
	}
	
	@Override
	public E peek() {
		if (isEmpty()) throw new EmptyStackException();
		
		return top.data;
	}
	
	@Override
	public boolean isEmpty() {
		return top == null;
	}
	
	@Override
	public int size() {
		int res = 0;
		for (Node<E> tmp = top; tmp != null; tmp = tmp.link) {
			++res;
		}
		return res;
	}

	@Override
	public String toString() {
		return "SsafyStack [top=" + top + "]";
	}
}
```

```java
public class StackAPITest {
	public static void main(String[] args) {
		IStack<String> stack = new SsafyStack<>();
		System.out.println(stack.isEmpty() + "//" + stack.size());
		stack.push("손예림");
		System.out.println(stack);
		stack.push("김인송");
		System.out.println(stack);
		stack.push("조의재");
		System.out.println(stack);
		stack.push("김현호");
		System.out.println(stack);
		stack.push("이사야");
		System.out.println(stack);
		stack.push("김준형");
		System.out.println(stack);
		
		System.out.println(stack.peek()); // 삭제는 아님 출력에 찍기만
		System.out.println(stack);
		
		System.out.println("======================");
		// 스택 사이즈 넘으면 EmptyStackException 발생 -> 런타임에 발생 unchecked
		// for (int i = 0; i < 7; i++) {
		while(!stack.isEmpty()) {
			System.out.println(stack.pop());
			System.out.println(stack);
		}
	}
}

/*
true//0
SsafyStack [top=Node [data=손예림, link=null]]
SsafyStack [top=Node [data=김인송, link=Node [data=손예림, link=null]]]
SsafyStack [top=Node [data=조의재, link=Node [data=김인송, link=Node [data=손예림, link=null]]]]
SsafyStack [top=Node [data=김현호, link=Node [data=조의재, link=Node [data=김인송, link=Node [data=손예림, link=null]]]]]
SsafyStack [top=Node [data=이사야, link=Node [data=김현호, link=Node [data=조의재, link=Node [data=김인송, link=Node [data=손예림, link=null]]]]]]
SsafyStack [top=Node [data=김준형, link=Node [data=이사야, link=Node [data=김현호, link=Node [data=조의재, link=Node [data=김인송, link=Node [data=손예림, link=null]]]]]]]
김준형
SsafyStack [top=Node [data=김준형, link=Node [data=이사야, link=Node [data=김현호, link=Node [data=조의재, link=Node [data=김인송, link=Node [data=손예림, link=null]]]]]]]
======================
김준형
SsafyStack [top=Node [data=이사야, link=Node [data=김현호, link=Node [data=조의재, link=Node [data=김인송, link=Node [data=손예림, link=null]]]]]]
이사야
SsafyStack [top=Node [data=김현호, link=Node [data=조의재, link=Node [data=김인송, link=Node [data=손예림, link=null]]]]]
김현호
SsafyStack [top=Node [data=조의재, link=Node [data=김인송, link=Node [data=손예림, link=null]]]]
조의재
SsafyStack [top=Node [data=김인송, link=Node [data=손예림, link=null]]]
김인송
SsafyStack [top=Node [data=손예림, link=null]]
손예림
SsafyStack [top=null]
*/
```

---

## 6. 리스트 관련 알고리즘: 슬라이딩 윈도우

시간 복잡도 O(N)

보통 배열이나 리스트에서 **고정된 크기**의 연속된 구간을 효율적으로 탐색하는 기법

고정 사이즈의 윈도우가 이동하면서 문제 풀이

각 윈도우의 공통된 **교집합 정보를 재사용**하고, **차이가 나는 양쪽 끝 원소만 갱신**

![image.png](image%202.png)