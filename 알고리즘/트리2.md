# 알고리즘 - 트리2

## 1. 트리 탐색 구현 - BFS

```java
package tree;

import java.io.BufferedReader;
import java.util.ArrayDeque;
import java.util.Queue;

public class CompleteBinaryTree<T> {
	private Object[] nodes;
	private final int SIZE;
	private int lastIndex = 0;
	
	public CompleteBinaryTree(int size) { // size: 최대 노드 개수
		SIZE = size;
		nodes = new Object[size + 1];
	}
	
	public boolean isEmpty() {
		return lastIndex == 0;
	}
	
	public boolean isFull() {
		return lastIndex == SIZE;
	}
	
	public void add(T e) {
		if (isFull()) throw new RuntimeException("포화 상태입니다.");
		
		nodes[++lastIndex] = e;
	}
	
	public void bfs() {
		if (isEmpty()) return;
		
		// 탐색대상의 순서를 관리할 큐 생성
		Queue<Integer> queue = new ArrayDeque<Integer>();
		// 첫 번째로 탐색할 대상 큐에 넣기
		queue.offer(1);
		// 탐색대상이 있으면 반복
		while (!queue.isEmpty()) {
			// 탐색대상 알아내기
			int current = queue.poll();
			// 탐색
			System.out.println(nodes[current]);
			// 탐색 대상의 자식노드를 체크해서 후에 탐색이 되도록 큐에 넣기
			if (current * 2 <= lastIndex) queue.offer(current * 2);
			if (current * 2 + 1 <= lastIndex) queue.offer(current * 2 + 1);
		}
	}
	
	public void bfs2() {
		if (isEmpty()) return;
		
		// 탐색대상의 순서를 관리할 큐 생성
		Queue<int[]> queue = new ArrayDeque<int[]>();
		// 첫 번째로 탐색할 대상과 너비 정보 큐에 넣기
		queue.offer(new int[] {1, 0});
		// 탐색대상이 있으면 반복
		while (!queue.isEmpty()) {
			// 탐색대상 알아내기
			int[] info = queue.poll();
			int current = info[0];
			int breadth = info[1];
			// 탐색
			System.out.println(nodes[current] + "/" + breadth);
			// 탐색 대상의 자식노드를 체크해서 후에 탐색이 되도록 큐에 넣기
			if (current * 2 <= lastIndex) 
				queue.offer(new int[] {current * 2, breadth + 1});
			if (current * 2 + 1 <= lastIndex) 
				queue.offer(new int[] {current * 2 + 1, breadth + 1});
		}
	}
	
	public void bfs3() {
		if (isEmpty()) return;
		
		int breadth = 0;
		
		// 탐색대상의 순서를 관리할 큐 생성
		Queue<Integer> queue = new ArrayDeque<Integer>();
		// 첫 번째로 탐색할 대상과 너비 정보 큐에 넣기
		queue.offer(1);
		
		// 탐색대상이 있으면 반복
		while (!queue.isEmpty()) {
			// 탐색대상 알아내기
			int size = queue.size();
			
			while (--size >= 0) {
				int current = queue.poll(); // 현재 큐에 들어있는 동일 너비의 탐색 개수
				// 탐색
				System.out.println(nodes[current] + "/" + breadth);
				// 탐색 대상의 자식노드를 체크해서 후에 탐색이 되도록 큐에 넣기
				if (current * 2 <= lastIndex) queue.offer(current * 2);
				if (current * 2 + 1 <= lastIndex) queue.offer(current * 2 + 1);
			}
			++breadth;
		}
	}
}

public class CompleteBinaryTreeTest {

	public static void main(String[] args) {
		String[] names = {"박준우", "안희수", "차희광", "김민준", "이규섭", "오양호", "오태양", "황우찬", "최동준"};
		CompleteBinaryTree<String> tree = new CompleteBinaryTree<>(names.length);
	
		for (String n : names) tree.add(n);
		
		tree.bfs3();
	}
}

/*
박준우/0
안희수/1
차희광/1
김민준/2
이규섭/2
오양호/2
오태양/2
황우찬/3
최동준/3
*/
```

---

## 2. 트리 탐색 - DFS

**DFS(Depth First Search): 깊이 우선 탐색**

가장 마지막에 만났던 갈림길의 노드로 되돌아가서 다시 깊이 우선 탐색을 반복하므로

재귀적으로 구현하거나 후입선출 구조의 **스택** 사용

**DFS 알고리즘**

```pascal
DFS(v)

	v 방문;
	for (v의 모든 자식 노드 w) {
		DFS(w);
	}
	
end DFS()
```

![탐색 순서: ABEFCDGHI](6dcf9bf6-ba8c-43c6-8244-d5a3a5128b06.png)

탐색 순서: ABEFCDGHI

---

## 3. 이진 트리 순회

**순회(traversal):** 트리의 노드들을 체계적으로 방문하는 

**3가지의 기본적인 순회 방법**

- **전위순회**(preorder traversal): **VLR**
    
    부모노드 → 왼쪽 자식노드 → 오른쪽 자식노드
    
- **중위순회**(inorder traversal): **LVR**
    
    왼쪽 자식노드 → 부모노드 → 오른쪽 자식노드
    
- **후위순회**(postorder traversal): **LRV**
    
    왼쪽 자식노드 → 오른쪽 자식노드 → 부모노드
    

### 전위 순회(preorder traversal)

**VLR**

부모 노드 → 왼쪽 자식 → 오른쪽 자식

```pascal
preorder_traverse (T)
	if (T is not null)
	{
		visit(T);
		preorder_traverse(T.left);
		preorder_traverse(T.right);
	}
End preorder_traverse
```

![image.png](image.png)

**순서:** A B D H I E C F G

### 중위 순회(inorder traversal)

**LVR**

왼쪽 자식 → 부모 노드 → 오른쪽 자식

```pascal
inorder_traverse (T)
	if (T is not null)
	{
		inorder_traverse(T.left);
		visit(T);
		inorder_traverse(T.right);
	}
End inorder_traverse
```

![image.png](image.png)

**순서:** H D I B E A F C G

### 후위 순회(postorder traversal)

**LRV**

왼쪽 자식 → 오른쪽 자식 → 부모 노드

```pascal
postorder_traverse (T)
	if (T is not null)
	{
		postorder_traverse(T.left);
		postorder_traverse(T.right);
		visit(T);
	}
End postorder_traverse
```

![image.png](image.png)

**순서:** H I D E B F G C A

```java
// current 노드를 루트로 하는 깊이 우선 트리 탐색
public void dfsByPreOrder(int current) {
	if (current > lastIndex) return;
	
	// 현재 노드 탐색
	System.out.println(nodes[current]);
	// 현재 노드의 자식 노드 탐색
	dfsByPreOrder(current * 2);
	dfsByPreOrder(current * 2 + 1);
}

public void dfsByInOrder(int current) {
	if (current > lastIndex) return;
	
	// 현재 노드의 자식 노드 탐색
	dfsByInOrder(current * 2);
	// 현재 노드 탐색
	System.out.println(nodes[current]);
	dfsByInOrder(current * 2 + 1);
}

public void dfsByPostOrder(int current) {
	if (current > lastIndex) return;
	
	// 현재 노드의 자식 노드 탐색
	dfsByPostOrder(current * 2);
	dfsByPostOrder(current * 2 + 1);
	// 현재 노드 탐색
	System.out.println(nodes[current]);
}
	

public class CompleteBinaryTreeTest {

	public static void main(String[] args) {
		String[] names = {"박준우", "안희수", "차희광", "김민준", "이규섭", "오양호", "오태양", "황우찬", "최동준"};
		CompleteBinaryTree<String> tree = new CompleteBinaryTree<>(names.length);
	
		for (String n : names) tree.add(n);
		
		System.out.println("=====preorder=====");
		tree.dfsByPreOrder(1);
		System.out.println("=====inorder=====");
		tree.dfsByInOrder(1);
		System.out.println("=====postorder=====");
		tree.dfsByPostOrder(1);
	}
}

/*
			박준우
		안희수 	차희광
	김민준 이규섭 오양호 오태양
황우찬 최동준
*/

/* result
=====preorder=====
박준우
안희수
김민준
황우찬
최동준
이규섭
차희광
오양호
오태양
=====inorder=====
황우찬
김민준
최동준
안희수
이규섭
박준우
오양호
차희광
오태양
=====postorder=====
황우찬
최동준
김민준
이규섭
안희수
오양호
오태양
차희광
박준우
*/
```

### 수식 트리

수식을 표현하는 이진 트리

**연산자**는 **루트 노드**이거나 **가지 노드**

**피연산자**는 모두 **리프 노드**

![image.png](image%201.png)

**중위 순회:** A / B * C * D + E

**후위 순회:** A B / C * D * E +

**전위 순회:** + * * / A B C D E

---

## 4. 힙(Heap)

완전 이진 트리에 있는 노드 중에서 키 값이 가장 큰 노드나 가장 작은 노드를 찾기 위해서 만든 자료구조

**최대 힙(max heap)**

키 값이 가장 큰 노드를 찾기 위한 **완전 이진 트리**

부모 노드의 키 값 ≥ 자식 노드의 키 값

루트 노드: 키 값이 가장 큰 노드

**최소 힙(min heap)**

키 값이 가장 작은 노드를 찾기 위한 **완전 이진 트리**

부모 노드의 키 값 ≤ 자식 노드의 키 값

루트 노드: 키 값이 가장 작은 노드

### 힙 연산 - 삭제

힙에서는 **루트 노드의 원소만을 삭제**할 수 있음

힙의 종류에 따라 최댓값 또는 최솟값을 구할 수 있음

### 힙(Heap) 활용 - 우선순위 큐

우선순위를 가진 항목들을 저장하는 큐

FIFO 순서가 아니라 우선순위가 높은 순서대로 먼저 나감

**Java.util.PriorityQueue**

Heap 자료구조

- 최대 Heap
    
    가장 큰 값을 기준으로 먼저 나옴
    
- 최소 Heap
    
    가장 작은 값을 기준으로 먼저 나옴
    

**java.util.PriorityQueue()**

원소들의 natural Ordering에 따라 Heap 유지

반드시 모든 원소는 Comparable 인터페이스를 구현해야 함

**java.util.PriorityQueue(Comparator comparator)**

명시된 Comparator의 구현에 따라 원소들의 순서를 유지