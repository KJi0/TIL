# 알고리즘 - 순열

## 완전 검색

모든 경우의 수를 나열해 보고 확인하는 기법

Brute-force 혹은 generate-and-test 기법

일반적으로 경우의 수가 적을 때 유용

**우선 완전 검색으로 접근해 해답을 도출한 후,**

**성능 개선을 위해 다른 알고리즘을 사용하고 해답을 확인하는 것이 바람직!**

많은 종류의 문제들이 **특정 조건을 만족하는 경우**나 **요소를 찾는 것**

이들은 전형적으로 **순열(permutation), 조합(combination), 부분집합(subset)**과 같은 조합적 문제들과 연관

---

### 완전 검색 - 순열(Permutation)

서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것

서로 다른 n개 중 r개를 택하는 순열 → **nPr**

**nPr** = n * (n-1) * (n-2) * … * (n-r+1)

**nPn** = n! (Factorial)

**순열 대표 문제**: TSP(Traveling Salesman Problem) 외판원 순회 문제

N개의 요소들에 대해서 n!개의 순열들이 존재

12! = 479,001,600

→ n > 12인 경우, 시간 복잡도 폭발적 증가

**⇒ 10 ≤ N ≤ 20**

---

### 순열 구현

{1, 2, 3}을 포함하는 모든 순열 생성하기

**반복문**

```pascal
for i from 1 to 3
	for j from 1 to 3
		if (j != i) then
			for k from 1 to 3
				if k != i and k != j then
					print i, j, k
				end if
			end for
		end if
	end for
end for

// 3! = 3 x 2 x 1 = 6가지
```

→ 입력이 {1, 2, 3, 4}로 달라지면 코드를 수정해야 함

**재귀**

```pascal
numbers[] : 순열 저장 배열
isSelected[] : 인덱스에 해당하는 숫자가 사용 중인지 저장하는 배열
perm(cnt) // cnt : 현재까지 뽑은 순열 수의 개수
	if cnt == 3
		순열 생성 완료
	else
		for i from 1 to 3
			if isSelected[i] == true then continue
			numbers[cnt] ← i
			isSelected[i] ← true
			perm(cnt + 1)
			isSelected[i] ← false
		end for
```