# 알고리즘 - 연결리스트2

## 1. 이중 연결 리스트

양쪽 방향으로 순회할 수 있도록 노드를 연결한 리스트

두 개의 링크 필드와 한 개의 데이터 필드로 구성

![image.png](image.png)

### 삽입 연산

1. 새로운 노드를 생성하고 데이터를 저장
2. cur의 next를 new의 next에 연결
3. cur의 참조값을 new의 prev에 연결
4. new의 참조값을 new 이전 노드의 next에 연결
5. new의 참조값을 new 다음 노드의 prev에 연결

### 삭제 연산

1. 삭제할 노드 cur의 next를 이전 노드의 next에 연결
2. cur의 prev를 다음 노드의 prev에 연결
3. cur의 prev와 next를 NULL

---

## 2. 리스트 관련 알고리즘

### 투 포인터

**투 포인터**는 배열이나 리스트에서 두 개의 포인터를 사용해 문제를 해결하는 기법

원소가 **정렬**되어 있는 상황에서 두 개의 각 포인터가 가리키는 값을 이용해 처리

두 개의 각 포인터가 가리키는 가변적인 부분 배열을 처리

### 투 포인터 - 시작과 끝이 다른 경우

n개의 자연수로 이루어진 정렬된 배열에서 2개의 원소를 선택해 합이 m이 되는 경우

**동작 원리**

시작 지점과 끝 지점에 각각 포인터 설정 후 조건에 따라 시작 포인터, 끝 포인터를 이동시킴

```java
package twopointer;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.StringTokenizer;

public class TwoPointerTest1_두수의합 {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine(), " ");
		
		int N = Integer.parseInt(st.nextToken());
		int target = Integer.parseInt(st.nextToken());
		
		int[] arr = new int[N];
		st = new StringTokenizer(br.readLine(), " ");
		
		for (int i = 0; i < N; i++) {
			arr[i] = Integer.parseInt(st.nextToken()); 
		}
		
		Arrays.sort(arr);
		int s = 0, e = N - 1, ans = 0;
		while (s < e) {
			// 두 포인터 가리키는 값을 더함
			int sum = arr[s] + arr[e];
			if (sum == target) { // 더한 값이 목표값과 같다
				++ans;
				s++; --e;
			} else if (sum < target) { // 더한 값이 목표값보다 작다: 값을 크게 만들자
				++s;
			} else { // 더한 값이 목표값보다 크다: 값을 작게 만들자
				--e;
			}
		}
		
		System.out.println(ans);
	}
}

/*
9 13
5 12 7 10 9 1 2 3 11
3
*/
```

### 투 포인터 - 시작과 끝이 동일한 경우

n개의 자연수로 된 수열 A[n]에서 i번째 수부터 j번째 수까지의 합 A[i] + A[i + 1] + … + A[j - 1] + A[j]가 m이 되는 경우

```java
package twopointer;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;

public class TwoPointerTest2_구간합 {

	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		StringTokenizer st = new StringTokenizer(br.readLine(), " ");
		
		int N = Integer.parseInt(st.nextToken());
		int target = Integer.parseInt(st.nextToken());
		
		int[] arr = new int[N];
		st = new StringTokenizer(br.readLine(), " ");
		
		for (int i = 0; i < N; i++) {
			arr[i] = Integer.parseInt(st.nextToken()); 
		}
		
		int s, e, cnt, sum;
		s = e = cnt = sum = 0;
		
		while(true) {
			if (sum >= target) {
				if (sum == target) ++cnt;
				sum -= arr[s++];
			} else if (e == N) { // 합이 목표합보다 작다면 e를 증가시켜야 하는 상황인데 e가 더 이상 뒤로 갈 수 없음
				break;
			} else { // 합이 목표합보다 작다면 e를 증가
				sum += arr[e++];
			}
		}
		
		System.out.println(cnt);
	}
}
```