# 알고리즘 - 스택

## 1. 스택(Stack)

### 스택의 특성

자료를 쌓아 올린 형태의 자료구조

스택에 저장된 자료는 **선형 구조**를 가짐

- 선형 구조: 자료 간의 관계가 **1 대 1**
- 비선형 구조: 자료 간의 관계가 1 대 N (ex: 트리)

**후입선출구조 (LIFO**, Last-In-First-Out)

마지막에 삽입한 자료를 가장 먼저 꺼냄

### 주요 메소드

- push(): 삽입
- pop(): 삭제 (역순으로 꺼냄)
- peek(): 스택 top에 있는 원소 반환
- isEmpty()
- size()

### 스택 응용

**괄호 검사**

괄호는 “쌍”

오른쪽 괄호는 왼쪽에서 가장 마지막 열린 괄호가 필요함 ⇒ 스택 이용

**Function call**

프로그램에서의 함수 호출과 복귀에 따른 수행 순서를 관리

가장 마지막에 호출된 함수가 가장 먼저 실행을 완료하고 복귀하는 후입선출 구조

함수 호출이 발생하면 호출한 함수 수행에 필요한 정보를 **스택 프레임**에 저장해 시스템 스택에 삽입

함수 실행이 끝나면 시스템 스택의 top 원소(스택 프레임)를 삭제(pop)하면서 프레임에 저장된 주소로 복귀

전체 종료되면 시스템 스택은 공백 스택이 됨

![image.png](image.png)

```java
import java.util.Stack;

public class StackAPITest {
	public static void main(String[] args) {
		Stack<String> stack = new Stack<>();
		System.out.println(stack.isEmpty() + "//" + stack.size());
		stack.push("손예림");
		System.out.println(stack);
		stack.push("김인송");
		System.out.println(stack);
		stack.push("조의재");
		System.out.println(stack);
		stack.push("김현호");
		System.out.println(stack);
		stack.push("이사야");
		System.out.println(stack);
		stack.push("김준형");
		System.out.println(stack);
		//System.out.println(stack.isEmpty() + "//" + stack.size());
		
		System.out.println(stack.peek()); // 삭제는 아님 출력에 찍기만
		System.out.println(stack);
		
		System.out.println("======================");
		// 스택 사이즈 넘으면 EmptyStackException 발생 -> 런타임에 발생 unchecked
		// for (int i = 0; i < 7; i++) {
		while(!stack.isEmpty()) {
			System.out.println(stack.pop());
			System.out.println(stack);
		}
	}
}

/*
true//0
[손예림]
[손예림, 김인송]
[손예림, 김인송, 조의재]
[손예림, 김인송, 조의재, 김현호]
[손예림, 김인송, 조의재, 김현호, 이사야]
[손예림, 김인송, 조의재, 김현호, 이사야, 김준형]
김준형
[손예림, 김인송, 조의재, 김현호, 이사야, 김준형]
======================
김준형
[손예림, 김인송, 조의재, 김현호, 이사야]
이사야
[손예림, 김인송, 조의재, 김현호]
김현호
[손예림, 김인송, 조의재]
조의재
[손예림, 김인송]
김인송
[손예림]
손예림
[]
*/
```

---

## 2. 스택 활용 - 계산기

- **중위표기법(infix notation)**

연산자를 피연산자의 **가운데** 표기하는 방법

ex) A+B

- **후위표기법(postfix notation)**

연산자를 피연산자 **뒤에** 표기하는 방법

ex) AB+

→ **후위표기법의 수식을 스택을 이용해 계산**

```java
import java.util.Stack;

public class StackCalculatorTest {
	public static void main(String[] args) {
		String expression = "6528-*2/+";
		Stack<Integer> stack = new Stack<>();
		
		for (int i = 0, size = expression.length(); i < size; i++) {
			char tmp = expression.charAt(i);
			if (Character.isDigit(tmp)) {
				int k = tmp - '0';
				stack.push(k);
			} else {
				int value2 = stack.pop();
				int value1 = stack.pop();
				int result = 0;
				
				switch (tmp) {
				case '+':
					result = value1 + value2;
					break;
				case '-':
					result = value1 - value2;
					break;
				case '*':	
					result = value1 * value2;
					break;
				case '/':				
					result = value1 / value2;
					break;
				}
				stack.push(result);
			}
		}
		System.out.println(stack.pop());
	}
}
```

![image.png](image%201.png)

---

## 3. 스택 활용 - 브라우저

표준 웹 브라우저는 방문한 페이지들 내에서 이전, 이후 페이지를 방문하는 기능이 있음

Back: 현재 페이지를 Forward 스택에 넣어 두고 Back 스택에서 꺼내 방문

Forward: 현재 페이지를 Back 스택에 넣어 두고 Forward 스택에서 꺼내 방문

→ 스택 2개 사용

![image.png](image%202.png)

---

## 4. 재귀 호출

**반복**은 수행하는 작업이 완료될 때까지 반복

- 루프 (for/while, do~while 구조)

**재귀**는 주어진 문제의 해를 구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법

- 하나의 큰 문제를 해결하기 쉬운 더 작은 문제로 쪼개고 결과들을 결합
- 재귀 함수로 구현

### 재귀 함수 (recursive function)

함수 내부에서 직접 혹은 간접적으로 자기 자신을 호출하는 함수

기본 부분(basic part)와 유도 부분(inductive part)로 구성

함수 호출은 스택 사용

→ 재귀 호출은 **반복적인 스택 사용**을 의미하며 메모리 및 속도에서 **성능 저하**가 발생